{"hits":[{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"arrayBaseOffset","lines":[[79,51,66]]},{"name":"getUnsafe","lines":[[136,23,32]]},{"name":"arrayIndexScale","lines":[[79,86,101]]}]}],"score":487,"fileName":"infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/container/entries/PrimitiveEntrySizeCalculator.java","fileContent":"package org.infinispan.container.entries;\n\nimport org.infinispan.commons.util.concurrent.jdk8backported.AbstractEntrySizeCalculatorHelper;\nimport sun.misc.Unsafe;\n\nimport java.lang.reflect.Array;\n\n/**\n * Entry Size calculator that returns an approximation of how much various primitives, primitive wrappers, Strings,\n * and arrays\n * @author wburns\n * @since 8.0\n */\npublic class PrimitiveEntrySizeCalculator extends AbstractEntrySizeCalculatorHelper<Object, Object> {\n   public long calculateSize(Object key, Object value) {\n      return handleObject(key) + handleObject(value);\n   }\n\n   protected long handleObject(Object object) {\n      Class<?> objClass = object.getClass();\n      if (objClass == String.class) {\n         String realString = (String) object;\n         // The string is an object and has a reference to its class, int for the hash code and a pointer to the char[]\n         long objectSize = roundUpToNearest8(OBJECT_SIZE + POINTER_SIZE + 4 + POINTER_SIZE);\n         // We then include the char[] offset and size\n         return objectSize + roundUpToNearest8(Unsafe.ARRAY_CHAR_BASE_OFFSET + realString.length() *\n                 Unsafe.ARRAY_CHAR_INDEX_SCALE);\n      } else if (objClass == Long.class) {\n         long longValue = ((Long) object).longValue();\n         if (longValue >= LongCacheConstraints.MIN_CACHE_VALUE &&\n                 longValue <= LongCacheConstraints.MAX_CACHE_VALUE) {\n            return 0;\n         }\n         // We add in the size for a long, plus the object reference and the class ref\n         return roundUpToNearest8(Unsafe.ARRAY_LONG_INDEX_SCALE + OBJECT_SIZE + POINTER_SIZE);\n      } else if (objClass == Integer.class) {\n         int intValue = ((Integer) object).intValue();\n         if (intValue >= IntegerCacheConstraints.MIN_CACHE_VALUE &&\n                 intValue <= IntegerCacheConstraints.MAX_CACHE_VALUE) {\n            return 0;\n         }\n         // We add in the size for a long, plus the object reference and the class ref\n         return roundUpToNearest8(Unsafe.ARRAY_INT_INDEX_SCALE + OBJECT_SIZE + POINTER_SIZE);\n      } else if (objClass == Short.class) {\n         short shortValue = ((Short) object).shortValue();\n         if (shortValue >= ShortCacheConstraints.MIN_CACHE_VALUE &&\n                 shortValue <= ShortCacheConstraints.MAX_CACHE_VALUE) {\n            return 0;\n         }\n         return roundUpToNearest8(Unsafe.ARRAY_SHORT_INDEX_SCALE + OBJECT_SIZE + POINTER_SIZE);\n      } else if (objClass == Double.class) {\n         return roundUpToNearest8(Unsafe.ARRAY_DOUBLE_INDEX_SCALE + OBJECT_SIZE + POINTER_SIZE);\n      } else if (objClass == Float.class) {\n         return roundUpToNearest8(Unsafe.ARRAY_FLOAT_INDEX_SCALE + OBJECT_SIZE + POINTER_SIZE);\n      } else if (objClass == Boolean.class) {\n         // We assume all provided booleans are cached\n         return 0;\n      } else if (objClass == Character.class) {\n         char charValue = ((Character) object).charValue();\n         if (charValue >= CharacterCacheConstraints.MIN_CACHE_VALUE &&\n                 charValue <= CharacterCacheConstraints.MAX_CACHE_VALUE) {\n            return 0;\n         }\n         return roundUpToNearest8(Unsafe.ARRAY_CHAR_INDEX_SCALE + OBJECT_SIZE + POINTER_SIZE);\n      } else if (objClass == Byte.class) {\n         // All byte values are cached\n         return 0;\n      } else if (objClass.isArray()) {\n         // We assume the array is of a type that supports shallow copy, such as the ones above\n         // We don't verify cached values if the array contains Booleans for example\n         Unsafe unsafe = getUnsafe();\n         Class<?> compClass = objClass.getComponentType();\n         int arrayLength = Array.getLength(object);\n         // Every array has a base offset which defines how large the array is and other overhead.\n         // Then each element in the array is indexed contiguously in memory thus we can simply multiply how\n         // many elements are in the array by how much of an offset each element requires.  A normal object for example\n         // takes up the standard Object pointer worth of size but primitives take up space equivalent to how many byte\n         // they occupy.\n         long arraySize = roundUpToNearest8(unsafe.arrayBaseOffset(objClass) + unsafe.arrayIndexScale(objClass) *\n                 arrayLength);\n         // If the component type isn't primitive we have to add in each of the instances\n         if (!compClass.isPrimitive()) {\n            // TODO: we could assume some values for given primitive wrappers.\n            for (int i = 0; i < arrayLength; ++i) {\n               arraySize += handleObject(Array.get(object, i));\n            }\n         }\n         return arraySize;\n      } else {\n         throw new IllegalArgumentException(\"Size of Class \" + objClass +\n                 \" cannot be determined using given entry size calculator :\" + getClass());\n      }\n   }\n\n   static class CharacterCacheConstraints {\n      static final short MAX_CACHE_VALUE = 127;\n      static final short MIN_CACHE_VALUE = 0;\n   }\n\n   static class ShortCacheConstraints {\n      static final short MAX_CACHE_VALUE = 127;\n      static final short MIN_CACHE_VALUE = -128;\n   }\n\n   static class LongCacheConstraints {\n      static final long MAX_CACHE_VALUE = 127;\n      static final long MIN_CACHE_VALUE = -128;\n   }\n\n   static class IntegerCacheConstraints {\n      static final int MAX_CACHE_VALUE = calculateMaxIntCache();\n      static final int MIN_CACHE_VALUE = -128;\n\n      static int calculateMaxIntCache() {\n         //We start from 128 as caching numbers up to 127 is required by the JLS:\n         //see 5.1.7 Boxing Conversion\n         for (int i = 128; i < Integer.MAX_VALUE; i++) {\n            if (Integer.valueOf(i) == Integer.valueOf(i))\n               continue;\n            else\n               return i - 1;\n         }\n         return Integer.MAX_VALUE;\n      }\n   }\n\n   /**\n    * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.\n    * Replace with a simple call to Unsafe.getUnsafe when integrating\n    * into a jdk.\n    *\n    * @return a sun.misc.Unsafe\n    */\n   static Unsafe getUnsafe() {\n      try {\n         return Unsafe.getUnsafe();\n      } catch (SecurityException tryReflectionInstead) {}\n      try {\n         return java.security.AccessController.doPrivileged\n                 (new java.security.PrivilegedExceptionAction<Unsafe>() {\n                    public Unsafe run() throws Exception {\n                       Class<Unsafe> k = Unsafe.class;\n                       for (java.lang.reflect.Field f : k.getDeclaredFields()) {\n                          f.setAccessible(true);\n                          Object x = f.get(null);\n                          if (k.isInstance(x))\n                             return k.cast(x);\n                       }\n                       throw new NoSuchFieldError(\"the Unsafe\");\n                    }});\n      } catch (java.security.PrivilegedActionException e) {\n         throw new RuntimeException(\"Could not initialize intrinsics\",\n                 e.getCause());\n      }\n   }\n}\n"},{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"compareAndSwapObject","lines":[[1865,23,43],[1868,23,43]]},{"name":"compareAndSwapInt","lines":[[1862,23,40],[1859,23,40]]},{"name":"getUnsafe","lines":[[1808,26,35]]},{"name":"compareAndSwapLong","lines":[[1856,23,41]]}]}],"score":387,"fileName":"scala/legacy-svn-scala/blob/master/src/forkjoin/scala/concurrent/forkjoin/ForkJoinPool.java","fileContent":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/licenses/publicdomain\n */\n\npackage scala.concurrent.forkjoin;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\nimport java.util.concurrent.atomic.*;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.*;\n\n/**\n * An {@link ExecutorService} for running {@link ForkJoinTask}s.  A\n * ForkJoinPool provides the entry point for submissions from\n * non-ForkJoinTasks, as well as management and monitoring operations.\n * Normally a single ForkJoinPool is used for a large number of\n * submitted tasks. Otherwise, use would not usually outweigh the\n * construction and bookkeeping overhead of creating a large set of\n * threads.\n *\n * <p>ForkJoinPools differ from other kinds of Executors mainly in\n * that they provide <em>work-stealing</em>: all threads in the pool\n * attempt to find and execute subtasks created by other active tasks\n * (eventually blocking if none exist). This makes them efficient when\n * most tasks spawn other subtasks (as do most ForkJoinTasks), as well\n * as the mixed execution of some plain Runnable- or Callable- based\n * activities along with ForkJoinTasks. When setting\n * <tt>setAsyncMode</tt>, a ForkJoinPools may also be appropriate for\n * use with fine-grained tasks that are never joined. Otherwise, other\n * ExecutorService implementations are typically more appropriate\n * choices.\n *\n * <p>A ForkJoinPool may be constructed with a given parallelism level\n * (target pool size), which it attempts to maintain by dynamically\n * adding, suspending, or resuming threads, even if some tasks are\n * waiting to join others. However, no such adjustments are performed\n * in the face of blocked IO or other unmanaged synchronization. The\n * nested <code>ManagedBlocker</code> interface enables extension of\n * the kinds of synchronization accommodated.  The target parallelism\n * level may also be changed dynamically (<code>setParallelism</code>)\n * and thread construction can be limited using methods\n * <code>setMaximumPoolSize</code> and/or\n * <code>setMaintainsParallelism</code>.\n *\n * <p>In addition to execution and lifecycle control methods, this\n * class provides status check methods (for example\n * <code>getStealCount</code>) that are intended to aid in developing,\n * tuning, and monitoring fork/join applications. Also, method\n * <code>toString</code> returns indications of pool state in a\n * convenient form for informal monitoring.\n *\n * <p><b>Implementation notes</b>: This implementation restricts the\n * maximum number of running threads to 32767. Attempts to create\n * pools with greater than the maximum result in\n * IllegalArgumentExceptions.\n */\npublic class ForkJoinPool /*extends AbstractExecutorService*/ {\n\n    /*\n     * See the extended comments interspersed below for design,\n     * rationale, and walkthroughs.\n     */\n\n    /** Mask for packing and unpacking shorts */\n    private static final int  shortMask = 0xffff;\n\n    /** Max pool size -- must be a power of two minus 1 */\n    private static final int MAX_THREADS =  0x7FFF;\n\n    // placeholder for java.util.concurrent.RunnableFuture\n    interface RunnableFuture<T> extends Runnable {\n    }\n\n    /**\n     * Factory for creating new ForkJoinWorkerThreads.  A\n     * ForkJoinWorkerThreadFactory must be defined and used for\n     * ForkJoinWorkerThread subclasses that extend base functionality\n     * or initialize threads with different contexts.\n     */\n    public static interface ForkJoinWorkerThreadFactory {\n        /**\n         * Returns a new worker thread operating in the given pool.\n         *\n         * @param pool the pool this thread works in\n         * @throws NullPointerException if pool is null;\n         */\n        public ForkJoinWorkerThread newThread(ForkJoinPool pool);\n    }\n\n    /**\n     * Default ForkJoinWorkerThreadFactory implementation, creates a\n     * new ForkJoinWorkerThread.\n     */\n    static class  DefaultForkJoinWorkerThreadFactory\n        implements ForkJoinWorkerThreadFactory {\n        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {\n            try {\n                return new ForkJoinWorkerThread(pool);\n            } catch (OutOfMemoryError oom)  {\n                return null;\n            }\n        }\n    }\n\n    /**\n     * Creates a new ForkJoinWorkerThread. This factory is used unless\n     * overridden in ForkJoinPool constructors.\n     */\n    public static final ForkJoinWorkerThreadFactory\n        defaultForkJoinWorkerThreadFactory =\n        new DefaultForkJoinWorkerThreadFactory();\n\n    /**\n     * Permission required for callers of methods that may start or\n     * kill threads.\n     */\n    private static final RuntimePermission modifyThreadPermission =\n        new RuntimePermission(\"modifyThread\");\n\n    /**\n     * If there is a security manager, makes sure caller has\n     * permission to modify threads.\n     */\n    private static void checkPermission() {\n        SecurityManager security = System.getSecurityManager();\n        if (security != null)\n            security.checkPermission(modifyThreadPermission);\n    }\n\n    /**\n     * Generator for assigning sequence numbers as pool names.\n     */\n    private static final AtomicInteger poolNumberGenerator =\n        new AtomicInteger();\n\n    /**\n     * Array holding all worker threads in the pool. Initialized upon\n     * first use. Array size must be a power of two.  Updates and\n     * replacements are protected by workerLock, but it is always kept\n     * in a consistent enough state to be randomly accessed without\n     * locking by workers performing work-stealing.\n     */\n    public volatile ForkJoinWorkerThread[] workers;\n\n    /**\n     * Lock protecting access to workers.\n     */\n    private final ReentrantLock workerLock;\n\n    /**\n     * Condition for awaitTermination.\n     */\n    private final Condition termination;\n\n    /**\n     * The uncaught exception handler used when any worker\n     * abrupty terminates\n     */\n    private Thread.UncaughtExceptionHandler ueh;\n\n    /**\n     * Creation factory for worker threads.\n     */\n    private final ForkJoinWorkerThreadFactory factory;\n\n    /**\n     * Head of stack of threads that were created to maintain\n     * parallelism when other threads blocked, but have since\n     * suspended when the parallelism level rose.\n     */\n    private volatile WaitQueueNode spareStack;\n\n    /**\n     * Sum of per-thread steal counts, updated only when threads are\n     * idle or terminating.\n     */\n    private final AtomicLong stealCount;\n\n    /**\n     * Queue for external submissions.\n     */\n    private final LinkedTransferQueue<ForkJoinTask<?>> submissionQueue;\n\n    /**\n     * Head of Treiber stack for barrier sync. See below for explanation\n     */\n    private volatile WaitQueueNode syncStack;\n\n    /**\n     * The count for event barrier\n     */\n    private volatile long eventCount;\n\n    /**\n     * Pool number, just for assigning useful names to worker threads\n     */\n    private final int poolNumber;\n\n    /**\n     * The maximum allowed pool size\n     */\n    private volatile int maxPoolSize;\n\n    /**\n     * The desired parallelism level, updated only under workerLock.\n     */\n    private volatile int parallelism;\n\n    /**\n     * True if use local fifo, not default lifo, for local polling\n     */\n    private volatile boolean locallyFifo;\n\n    /**\n     * Holds number of total (i.e., created and not yet terminated)\n     * and running (i.e., not blocked on joins or other managed sync)\n     * threads, packed into one int to ensure consistent snapshot when\n     * making decisions about creating and suspending spare\n     * threads. Updated only by CAS.  Note: CASes in\n     * updateRunningCount and preJoin running active count is in low\n     * word, so need to be modified if this changes\n     */\n    private volatile int workerCounts;\n\n    private static int totalCountOf(int s)           { return s >>> 16;  }\n    private static int runningCountOf(int s)         { return s & shortMask; }\n    private static int workerCountsFor(int t, int r) { return (t << 16) + r; }\n\n    /**\n     * Add delta (which may be negative) to running count.  This must\n     * be called before (with negative arg) and after (with positive)\n     * any managed synchronization (i.e., mainly, joins)\n     * @param delta the number to add\n     */\n    final void updateRunningCount(int delta) {\n        int s;\n        do;while (!casWorkerCounts(s = workerCounts, s + delta));\n    }\n\n    /**\n     * Add delta (which may be negative) to both total and running\n     * count.  This must be called upon creation and termination of\n     * worker threads.\n     * @param delta the number to add\n     */\n    private void updateWorkerCount(int delta) {\n        int d = delta + (delta << 16); // add to both lo and hi parts\n        int s;\n        do;while (!casWorkerCounts(s = workerCounts, s + d));\n    }\n\n    /**\n     * Lifecycle control. High word contains runState, low word\n     * contains the number of workers that are (probably) executing\n     * tasks. This value is atomically incremented before a worker\n     * gets a task to run, and decremented when worker has no tasks\n     * and cannot find any. These two fields are bundled together to\n     * support correct termination triggering.  Note: activeCount\n     * CAS'es cheat by assuming active count is in low word, so need\n     * to be modified if this changes\n     */\n    private volatile int runControl;\n\n    // RunState values. Order among values matters\n    private static final int RUNNING     = 0;\n    private static final int SHUTDOWN    = 1;\n    private static final int TERMINATING = 2;\n    private static final int TERMINATED  = 3;\n\n    private static int runStateOf(int c)             { return c >>> 16; }\n    private static int activeCountOf(int c)          { return c & shortMask; }\n    private static int runControlFor(int r, int a)   { return (r << 16) + a; }\n\n    /**\n     * Try incrementing active count; fail on contention. Called by\n     * workers before/during executing tasks.\n     * @return true on success;\n     */\n    final boolean tryIncrementActiveCount() {\n        int c = runControl;\n        return casRunControl(c, c+1);\n    }\n\n    /**\n     * Try decrementing active count; fail on contention.\n     * Possibly trigger termination on success\n     * Called by workers when they can't find tasks.\n     * @return true on success\n     */\n    final boolean tryDecrementActiveCount() {\n        int c = runControl;\n        int nextc = c - 1;\n        if (!casRunControl(c, nextc))\n            return false;\n        if (canTerminateOnShutdown(nextc))\n            terminateOnShutdown();\n        return true;\n    }\n\n    /**\n     * Return true if argument represents zero active count and\n     * nonzero runstate, which is the triggering condition for\n     * terminating on shutdown.\n     */\n    private static boolean canTerminateOnShutdown(int c) {\n        return ((c & -c) >>> 16) != 0; // i.e. least bit is nonzero runState bit\n    }\n\n    /**\n     * Transition run state to at least the given state. Return true\n     * if not already at least given state.\n     */\n    private boolean transitionRunStateTo(int state) {\n        for (;;) {\n            int c = runControl;\n            if (runStateOf(c) >= state)\n                return false;\n            if (casRunControl(c, runControlFor(state, activeCountOf(c))))\n                return true;\n        }\n    }\n\n    /**\n     * Controls whether to add spares to maintain parallelism\n     */\n    private volatile boolean maintainsParallelism;\n\n    // Constructors\n\n    /**\n     * Creates a ForkJoinPool with a pool size equal to the number of\n     * processors available on the system and using the default\n     * ForkJoinWorkerThreadFactory,\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public ForkJoinPool() {\n        this(Runtime.getRuntime().availableProcessors(),\n             defaultForkJoinWorkerThreadFactory);\n    }\n\n    /**\n     * Creates a ForkJoinPool with the indicated parellelism level\n     * threads, and using the default ForkJoinWorkerThreadFactory,\n     * @param parallelism the number of worker threads\n     * @throws IllegalArgumentException if parallelism less than or\n     * equal to zero\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public ForkJoinPool(int parallelism) {\n        this(parallelism, defaultForkJoinWorkerThreadFactory);\n    }\n\n    /**\n     * Creates a ForkJoinPool with parallelism equal to the number of\n     * processors available on the system and using the given\n     * ForkJoinWorkerThreadFactory,\n     * @param factory the factory for creating new threads\n     * @throws NullPointerException if factory is null\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public ForkJoinPool(ForkJoinWorkerThreadFactory factory) {\n        this(Runtime.getRuntime().availableProcessors(), factory);\n    }\n\n    /**\n     * Creates a ForkJoinPool with the given parallelism and factory.\n     *\n     * @param parallelism the targeted number of worker threads\n     * @param factory the factory for creating new threads\n     * @throws IllegalArgumentException if parallelism less than or\n     * equal to zero, or greater than implementation limit.\n     * @throws NullPointerException if factory is null\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory) {\n        if (parallelism <= 0 || parallelism > MAX_THREADS)\n            throw new IllegalArgumentException();\n        if (factory == null)\n            throw new NullPointerException();\n        checkPermission();\n        this.factory = factory;\n        this.parallelism = parallelism;\n        this.maxPoolSize = MAX_THREADS;\n        this.maintainsParallelism = true;\n        this.poolNumber = poolNumberGenerator.incrementAndGet();\n        this.workerLock = new ReentrantLock();\n        this.termination = workerLock.newCondition();\n        this.stealCount = new AtomicLong();\n        this.submissionQueue = new LinkedTransferQueue<ForkJoinTask<?>>();\n        // worker array and workers are lazily constructed\n    }\n\n    /**\n     * Create new worker using factory.\n     * @param index the index to assign worker\n     * @return new worker, or null of factory failed\n     */\n    private ForkJoinWorkerThread createWorker(int index) {\n        Thread.UncaughtExceptionHandler h = ueh;\n        ForkJoinWorkerThread w = factory.newThread(this);\n        if (w != null) {\n            w.poolIndex = index;\n            w.setDaemon(true);\n            w.setAsyncMode(locallyFifo);\n            w.setName(\"ForkJoinPool-\" + poolNumber + \"-worker-\" + index);\n            if (h != null)\n                w.setUncaughtExceptionHandler(h);\n        }\n        return w;\n    }\n\n    /**\n     * Return a good size for worker array given pool size.\n     * Currently requires size to be a power of two.\n     */\n    private static int arraySizeFor(int ps) {\n        return ps <= 1? 1 : (1 << (32 - Integer.numberOfLeadingZeros(ps-1)));\n    }\n\n    public static ForkJoinWorkerThread[] copyOfWorkers(ForkJoinWorkerThread[] original, int newLength) {\n        ForkJoinWorkerThread[] copy = new ForkJoinWorkerThread[newLength];\n        System.arraycopy(original, 0, copy, 0, Math.min(newLength, original.length));\n        return copy;\n    }\n\n    /**\n     * Create or resize array if necessary to hold newLength.\n     * Call only under exlusion or lock\n     * @return the array\n     */\n    private ForkJoinWorkerThread[] ensureWorkerArrayCapacity(int newLength) {\n        ForkJoinWorkerThread[] ws = workers;\n        if (ws == null)\n            return workers = new ForkJoinWorkerThread[arraySizeFor(newLength)];\n        else if (newLength > ws.length)\n            return workers = copyOfWorkers(ws, arraySizeFor(newLength));\n        else\n            return ws;\n    }\n\n    /**\n     * Try to shrink workers into smaller array after one or more terminate\n     */\n    private void tryShrinkWorkerArray() {\n        ForkJoinWorkerThread[] ws = workers;\n        if (ws != null) {\n            int len = ws.length;\n            int last = len - 1;\n            while (last >= 0 && ws[last] == null)\n                --last;\n            int newLength = arraySizeFor(last+1);\n            if (newLength < len)\n                workers = copyOfWorkers(ws, newLength);\n        }\n    }\n\n    /**\n     * Initialize workers if necessary\n     */\n    final void ensureWorkerInitialization() {\n        ForkJoinWorkerThread[] ws = workers;\n        if (ws == null) {\n            final ReentrantLock lock = this.workerLock;\n            lock.lock();\n            try {\n                ws = workers;\n                if (ws == null) {\n                    int ps = parallelism;\n                    ws = ensureWorkerArrayCapacity(ps);\n                    for (int i = 0; i < ps; ++i) {\n                        ForkJoinWorkerThread w = createWorker(i);\n                        if (w != null) {\n                            ws[i] = w;\n                            w.start();\n                            updateWorkerCount(1);\n                        }\n                    }\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    /**\n     * Worker creation and startup for threads added via setParallelism.\n     */\n    private void createAndStartAddedWorkers() {\n        resumeAllSpares();  // Allow spares to convert to nonspare\n        int ps = parallelism;\n        ForkJoinWorkerThread[] ws = ensureWorkerArrayCapacity(ps);\n        int len = ws.length;\n        // Sweep through slots, to keep lowest indices most populated\n        int k = 0;\n        while (k < len) {\n            if (ws[k] != null) {\n                ++k;\n                continue;\n            }\n            int s = workerCounts;\n            int tc = totalCountOf(s);\n            int rc = runningCountOf(s);\n            if (rc >= ps || tc >= ps)\n                break;\n            if (casWorkerCounts (s, workerCountsFor(tc+1, rc+1))) {\n                ForkJoinWorkerThread w = createWorker(k);\n                if (w != null) {\n                    ws[k++] = w;\n                    w.start();\n                }\n                else {\n                    updateWorkerCount(-1); // back out on failed creation\n                    break;\n                }\n            }\n        }\n    }\n\n    // Execution methods\n\n    /**\n     * Common code for execute, invoke and submit\n     */\n    private <T> void doSubmit(ForkJoinTask<T> task) {\n        if (isShutdown())\n            throw new RejectedExecutionException();\n        if (workers == null)\n            ensureWorkerInitialization();\n        submissionQueue.offer(task);\n        signalIdleWorkers();\n    }\n\n    /**\n     * Performs the given task; returning its result upon completion\n     * @param task the task\n     * @return the task's result\n     * @throws NullPointerException if task is null\n     * @throws RejectedExecutionException if pool is shut down\n     */\n    public <T> T invoke(ForkJoinTask<T> task) {\n        doSubmit(task);\n        return task.join();\n    }\n\n    /**\n     * Arranges for (asynchronous) execution of the given task.\n     * @param task the task\n     * @throws NullPointerException if task is null\n     * @throws RejectedExecutionException if pool is shut down\n     */\n    public <T> void execute(ForkJoinTask<T> task) {\n        doSubmit(task);\n    }\n\n    // AbstractExecutorService methods\n\n    public void execute(Runnable task) {\n        doSubmit(new AdaptedRunnable<Void>(task, null));\n    }\n\n    public <T> ForkJoinTask<T> submit(Callable<T> task) {\n        ForkJoinTask<T> job = new AdaptedCallable<T>(task);\n        doSubmit(job);\n        return job;\n    }\n\n    public <T> ForkJoinTask<T> submit(Runnable task, T result) {\n        ForkJoinTask<T> job = new AdaptedRunnable<T>(task, result);\n        doSubmit(job);\n        return job;\n    }\n\n    public ForkJoinTask<?> submit(Runnable task) {\n        ForkJoinTask<Void> job = new AdaptedRunnable<Void>(task, null);\n        doSubmit(job);\n        return job;\n    }\n\n    /**\n     * Adaptor for Runnables. This implements RunnableFuture\n     * to be compliant with AbstractExecutorService constraints\n     */\n    static final class AdaptedRunnable<T> extends ForkJoinTask<T>\n        implements RunnableFuture<T> {\n        final Runnable runnable;\n        final T resultOnCompletion;\n        T result;\n        AdaptedRunnable(Runnable runnable, T result) {\n            if (runnable == null) throw new NullPointerException();\n            this.runnable = runnable;\n            this.resultOnCompletion = result;\n        }\n        public T getRawResult() { return result; }\n        public void setRawResult(T v) { result = v; }\n        public boolean exec() {\n            runnable.run();\n            result = resultOnCompletion;\n            return true;\n        }\n        public void run() { invoke(); }\n    }\n\n    /**\n     * Adaptor for Callables\n     */\n    static final class AdaptedCallable<T> extends ForkJoinTask<T>\n        implements RunnableFuture<T> {\n        final Callable<T> callable;\n        T result;\n        AdaptedCallable(Callable<T> callable) {\n            if (callable == null) throw new NullPointerException();\n            this.callable = callable;\n        }\n        public T getRawResult() { return result; }\n        public void setRawResult(T v) { result = v; }\n        public boolean exec() {\n            try {\n                result = callable.call();\n                return true;\n            } catch (Error err) {\n                throw err;\n            } catch (RuntimeException rex) {\n                throw rex;\n            } catch (Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n        public void run() { invoke(); }\n    }\n\n    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n        ArrayList<ForkJoinTask<T>> ts =\n            new ArrayList<ForkJoinTask<T>>(tasks.size());\n        for (Callable<T> c : tasks)\n            ts.add(new AdaptedCallable<T>(c));\n        invoke(new InvokeAll<T>(ts));\n        return (List<Future<T>>)(List)ts;\n    }\n\n    static final class InvokeAll<T> extends RecursiveAction {\n        final ArrayList<ForkJoinTask<T>> tasks;\n        InvokeAll(ArrayList<ForkJoinTask<T>> tasks) { this.tasks = tasks; }\n        public void compute() {\n            try { invokeAll(tasks); } catch(Exception ignore) {}\n        }\n    }\n\n    // Configuration and status settings and queries\n\n    /**\n     * Returns the factory used for constructing new workers\n     *\n     * @return the factory used for constructing new workers\n     */\n    public ForkJoinWorkerThreadFactory getFactory() {\n        return factory;\n    }\n\n    /**\n     * Returns the handler for internal worker threads that terminate\n     * due to unrecoverable errors encountered while executing tasks.\n     * @return the handler, or null if none\n     */\n    public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {\n        Thread.UncaughtExceptionHandler h;\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            h = ueh;\n        } finally {\n            lock.unlock();\n        }\n        return h;\n    }\n\n    /**\n     * Sets the handler for internal worker threads that terminate due\n     * to unrecoverable errors encountered while executing tasks.\n     * Unless set, the current default or ThreadGroup handler is used\n     * as handler.\n     *\n     * @param h the new handler\n     * @return the old handler, or null if none\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public Thread.UncaughtExceptionHandler\n        setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler h) {\n        checkPermission();\n        Thread.UncaughtExceptionHandler old = null;\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            old = ueh;\n            ueh = h;\n            ForkJoinWorkerThread[] ws = workers;\n            if (ws != null) {\n                for (int i = 0; i < ws.length; ++i) {\n                    ForkJoinWorkerThread w = ws[i];\n                    if (w != null)\n                        w.setUncaughtExceptionHandler(h);\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        return old;\n    }\n\n\n    /**\n     * Sets the target paralleism level of this pool.\n     * @param parallelism the target parallelism\n     * @throws IllegalArgumentException if parallelism less than or\n     * equal to zero or greater than maximum size bounds.\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public void setParallelism(int parallelism) {\n        checkPermission();\n        if (parallelism <= 0 || parallelism > maxPoolSize)\n            throw new IllegalArgumentException();\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            if (!isTerminating()) {\n                int p = this.parallelism;\n                this.parallelism = parallelism;\n                if (parallelism > p)\n                    createAndStartAddedWorkers();\n                else\n                    trimSpares();\n            }\n        } finally {\n            lock.unlock();\n        }\n        signalIdleWorkers();\n    }\n\n    /**\n     * Returns the targeted number of worker threads in this pool.\n     *\n     * @return the targeted number of worker threads in this pool\n     */\n    public int getParallelism() {\n        return parallelism;\n    }\n\n    /**\n     * Returns the number of worker threads that have started but not\n     * yet terminated.  This result returned by this method may differ\n     * from <code>getParallelism</code> when threads are created to\n     * maintain parallelism when others are cooperatively blocked.\n     *\n     * @return the number of worker threads\n     */\n    public int getPoolSize() {\n        return totalCountOf(workerCounts);\n    }\n\n    /**\n     * Returns the maximum number of threads allowed to exist in the\n     * pool, even if there are insufficient unblocked running threads.\n     * @return the maximum\n     */\n    public int getMaximumPoolSize() {\n        return maxPoolSize;\n    }\n\n    /**\n     * Sets the maximum number of threads allowed to exist in the\n     * pool, even if there are insufficient unblocked running threads.\n     * Setting this value has no effect on current pool size. It\n     * controls construction of new threads.\n     * @throws IllegalArgumentException if negative or greater then\n     * internal implementation limit.\n     */\n    public void setMaximumPoolSize(int newMax) {\n        if (newMax < 0 || newMax > MAX_THREADS)\n            throw new IllegalArgumentException();\n        maxPoolSize = newMax;\n    }\n\n\n    /**\n     * Returns true if this pool dynamically maintains its target\n     * parallelism level. If false, new threads are added only to\n     * avoid possible starvation.\n     * This setting is by default true;\n     * @return true if maintains parallelism\n     */\n    public boolean getMaintainsParallelism() {\n        return maintainsParallelism;\n    }\n\n    /**\n     * Sets whether this pool dynamically maintains its target\n     * parallelism level. If false, new threads are added only to\n     * avoid possible starvation.\n     * @param enable true to maintains parallelism\n     */\n    public void setMaintainsParallelism(boolean enable) {\n        maintainsParallelism = enable;\n    }\n\n    /**\n     * Establishes local first-in-first-out scheduling mode for forked\n     * tasks that are never joined. This mode may be more appropriate\n     * than default locally stack-based mode in applications in which\n     * worker threads only process asynchronous tasks.  This method is\n     * designed to be invoked only when pool is quiescent, and\n     * typically only before any tasks are submitted. The effects of\n     * invocations at ather times may be unpredictable.\n     *\n     * @param async if true, use locally FIFO scheduling\n     * @return the previous mode.\n     */\n    public boolean setAsyncMode(boolean async) {\n        boolean oldMode = locallyFifo;\n        locallyFifo = async;\n        ForkJoinWorkerThread[] ws = workers;\n        if (ws != null) {\n            for (int i = 0; i < ws.length; ++i) {\n                ForkJoinWorkerThread t = ws[i];\n                if (t != null)\n                    t.setAsyncMode(async);\n            }\n        }\n        return oldMode;\n    }\n\n    /**\n     * Returns true if this pool uses local first-in-first-out\n     * scheduling mode for forked tasks that are never joined. \n     *\n     * @return true if this pool uses async mode.\n     */\n    public boolean getAsyncMode() {\n        return locallyFifo;\n    }\n\n    /**\n     * Returns an estimate of the number of worker threads that are\n     * not blocked waiting to join tasks or for other managed\n     * synchronization.\n     *\n     * @return the number of worker threads\n     */\n    public int getRunningThreadCount() {\n        return runningCountOf(workerCounts);\n    }\n\n    /**\n     * Returns an estimate of the number of threads that are currently\n     * stealing or executing tasks. This method may overestimate the\n     * number of active threads.\n     * @return the number of active threads.\n     */\n    public int getActiveThreadCount() {\n        return activeCountOf(runControl);\n    }\n\n    /**\n     * Returns an estimate of the number of threads that are currently\n     * idle waiting for tasks. This method may underestimate the\n     * number of idle threads.\n     * @return the number of idle threads.\n     */\n    final int getIdleThreadCount() {\n        int c = runningCountOf(workerCounts) - activeCountOf(runControl);\n        return (c <= 0)? 0 : c;\n    }\n\n    /**\n     * Returns true if all worker threads are currently idle. An idle\n     * worker is one that cannot obtain a task to execute because none\n     * are available to steal from other threads, and there are no\n     * pending submissions to the pool. This method is conservative:\n     * It might not return true immediately upon idleness of all\n     * threads, but will eventually become true if threads remain\n     * inactive.\n     * @return true if all threads are currently idle\n     */\n    public boolean isQuiescent() {\n        return activeCountOf(runControl) == 0;\n    }\n\n    /**\n     * Returns an estimate of the total number of tasks stolen from\n     * one thread's work queue by another. The reported value\n     * underestimates the actual total number of steals when the pool\n     * is not quiescent. This value may be useful for monitoring and\n     * tuning fork/join programs: In general, steal counts should be\n     * high enough to keep threads busy, but low enough to avoid\n     * overhead and contention across threads.\n     * @return the number of steals.\n     */\n    public long getStealCount() {\n        return stealCount.get();\n    }\n\n    /**\n     * Accumulate steal count from a worker. Call only\n     * when worker known to be idle.\n     */\n    private void updateStealCount(ForkJoinWorkerThread w) {\n        int sc = w.getAndClearStealCount();\n        if (sc != 0)\n            stealCount.addAndGet(sc);\n    }\n\n    /**\n     * Returns an estimate of the total number of tasks currently held\n     * in queues by worker threads (but not including tasks submitted\n     * to the pool that have not begun executing). This value is only\n     * an approximation, obtained by iterating across all threads in\n     * the pool. This method may be useful for tuning task\n     * granularities.\n     * @return the number of queued tasks.\n     */\n    public long getQueuedTaskCount() {\n        long count = 0;\n        ForkJoinWorkerThread[] ws = workers;\n        if (ws != null) {\n            for (int i = 0; i < ws.length; ++i) {\n                ForkJoinWorkerThread t = ws[i];\n                if (t != null)\n                    count += t.getQueueSize();\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns an estimate of the number tasks submitted to this pool\n     * that have not yet begun executing. This method takes time\n     * proportional to the number of submissions.\n     * @return the number of queued submissions.\n     */\n    public int getQueuedSubmissionCount() {\n        return submissionQueue.size();\n    }\n\n    /**\n     * Returns true if there are any tasks submitted to this pool\n     * that have not yet begun executing.\n     * @return <code>true</code> if there are any queued submissions.\n     */\n    public boolean hasQueuedSubmissions() {\n        return !submissionQueue.isEmpty();\n    }\n\n    /**\n     * Removes and returns the next unexecuted submission if one is\n     * available.  This method may be useful in extensions to this\n     * class that re-assign work in systems with multiple pools.\n     * @return the next submission, or null if none\n     */\n    protected ForkJoinTask<?> pollSubmission() {\n        return submissionQueue.poll();\n    }\n\n    /**\n     * Removes all available unexecuted submitted and forked tasks\n     * from scheduling queues and adds them to the given collection,\n     * without altering their execution status. These may include\n     * artifically generated or wrapped tasks. This method id designed\n     * to be invoked only when the pool is known to be\n     * quiescent. Invocations at other times may not remove all\n     * tasks. A failure encountered while attempting to add elements\n     * to collection <tt>c</tt> may result in elements being in\n     * neither, either or both collections when the associated\n     * exception is thrown.  The behavior of this operation is\n     * undefined if the specified collection is modified while the\n     * operation is in progress.\n     * @param c the collection to transfer elements into\n     * @return the number of elements transferred\n     */\n    protected int drainTasksTo(Collection<ForkJoinTask<?>> c) {\n        int n = submissionQueue.drainTo(c);\n        ForkJoinWorkerThread[] ws = workers;\n        if (ws != null) {\n            for (int i = 0; i < ws.length; ++i) {\n                ForkJoinWorkerThread w = ws[i];\n                if (w != null)\n                    n += w.drainTasksTo(c);\n            }\n        }\n        return n;\n    }\n\n    /**\n     * Returns a string identifying this pool, as well as its state,\n     * including indications of run state, parallelism level, and\n     * worker and task counts.\n     *\n     * @return a string identifying this pool, as well as its state\n     */\n    public String toString() {\n        int ps = parallelism;\n        int wc = workerCounts;\n        int rc = runControl;\n        long st = getStealCount();\n        long qt = getQueuedTaskCount();\n        long qs = getQueuedSubmissionCount();\n        return super.toString() +\n            \"[\" + runStateToString(runStateOf(rc)) +\n            \", parallelism = \" + ps +\n            \", size = \" + totalCountOf(wc) +\n            \", active = \" + activeCountOf(rc) +\n            \", running = \" + runningCountOf(wc) +\n            \", steals = \" + st +\n            \", tasks = \" + qt +\n            \", submissions = \" + qs +\n            \"]\";\n    }\n\n    private static String runStateToString(int rs) {\n        switch(rs) {\n        case RUNNING: return \"Running\";\n        case SHUTDOWN: return \"Shutting down\";\n        case TERMINATING: return \"Terminating\";\n        case TERMINATED: return \"Terminated\";\n        default: throw new Error(\"Unknown run state\");\n        }\n    }\n\n    // lifecycle control\n\n    /**\n     * Initiates an orderly shutdown in which previously submitted\n     * tasks are executed, but no new tasks will be accepted.\n     * Invocation has no additional effect if already shut down.\n     * Tasks that are in the process of being submitted concurrently\n     * during the course of this method may or may not be rejected.\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public void shutdown() {\n        checkPermission();\n        transitionRunStateTo(SHUTDOWN);\n        if (canTerminateOnShutdown(runControl))\n            terminateOnShutdown();\n    }\n\n    /**\n     * Attempts to stop all actively executing tasks, and cancels all\n     * waiting tasks.  Tasks that are in the process of being\n     * submitted or executed concurrently during the course of this\n     * method may or may not be rejected. Unlike some other executors,\n     * this method cancels rather than collects non-executed tasks\n     * upon termination, so always returns an empty list. However, you\n     * can use method <code>drainTasksTo</code> before invoking this\n     * method to transfer unexecuted tasks to another collection.\n     * @return an empty list\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}<code>(\"modifyThread\")</code>,\n     */\n    public List<Runnable> shutdownNow() {\n        checkPermission();\n        terminate();\n        return Collections.emptyList();\n    }\n\n    /**\n     * Returns <code>true</code> if all tasks have completed following shut down.\n     *\n     * @return <code>true</code> if all tasks have completed following shut down\n     */\n    public boolean isTerminated() {\n        return runStateOf(runControl) == TERMINATED;\n    }\n\n    /**\n     * Returns <code>true</code> if the process of termination has\n     * commenced but possibly not yet completed.\n     *\n     * @return <code>true</code> if terminating\n     */\n    public boolean isTerminating() {\n        return runStateOf(runControl) >= TERMINATING;\n    }\n\n    /**\n     * Returns <code>true</code> if this pool has been shut down.\n     *\n     * @return <code>true</code> if this pool has been shut down\n     */\n    public boolean isShutdown() {\n        return runStateOf(runControl) >= SHUTDOWN;\n    }\n\n    /**\n     * Blocks until all tasks have completed execution after a shutdown\n     * request, or the timeout occurs, or the current thread is\n     * interrupted, whichever happens first.\n     *\n     * @param timeout the maximum time to wait\n     * @param unit the time unit of the timeout argument\n     * @return <code>true</code> if this executor terminated and\n     *         <code>false</code> if the timeout elapsed before termination\n     * @throws InterruptedException if interrupted while waiting\n     */\n    public boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException {\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            for (;;) {\n                if (isTerminated())\n                    return true;\n                if (nanos <= 0)\n                    return false;\n                nanos = termination.awaitNanos(nanos);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // Shutdown and termination support\n\n    /**\n     * Callback from terminating worker. Null out the corresponding\n     * workers slot, and if terminating, try to terminate, else try to\n     * shrink workers array.\n     * @param w the worker\n     */\n    final void workerTerminated(ForkJoinWorkerThread w) {\n        updateStealCount(w);\n        updateWorkerCount(-1);\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            ForkJoinWorkerThread[] ws = workers;\n            if (ws != null) {\n                int idx = w.poolIndex;\n                if (idx >= 0 && idx < ws.length && ws[idx] == w)\n                    ws[idx] = null;\n                if (totalCountOf(workerCounts) == 0) {\n                    terminate(); // no-op if already terminating\n                    transitionRunStateTo(TERMINATED);\n                    termination.signalAll();\n                }\n                else if (!isTerminating()) {\n                    tryShrinkWorkerArray();\n                    tryResumeSpare(true); // allow replacement\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        signalIdleWorkers();\n    }\n\n    /**\n     * Initiate termination.\n     */\n    private void terminate() {\n        if (transitionRunStateTo(TERMINATING)) {\n            stopAllWorkers();\n            resumeAllSpares();\n            signalIdleWorkers();\n            cancelQueuedSubmissions();\n            cancelQueuedWorkerTasks();\n            interruptUnterminatedWorkers();\n            signalIdleWorkers(); // resignal after interrupt\n        }\n    }\n\n    /**\n     * Possibly terminate when on shutdown state\n     */\n    private void terminateOnShutdown() {\n        if (!hasQueuedSubmissions() && canTerminateOnShutdown(runControl))\n            terminate();\n    }\n\n    /**\n     * Clear out and cancel submissions\n     */\n    private void cancelQueuedSubmissions() {\n        ForkJoinTask<?> task;\n        while ((task = pollSubmission()) != null)\n            task.cancel(false);\n    }\n\n    /**\n     * Clean out worker queues.\n     */\n    private void cancelQueuedWorkerTasks() {\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            ForkJoinWorkerThread[] ws = workers;\n            if (ws != null) {\n                for (int i = 0; i < ws.length; ++i) {\n                    ForkJoinWorkerThread t = ws[i];\n                    if (t != null)\n                        t.cancelTasks();\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Set each worker's status to terminating. Requires lock to avoid\n     * conflicts with add/remove\n     */\n    private void stopAllWorkers() {\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            ForkJoinWorkerThread[] ws = workers;\n            if (ws != null) {\n                for (int i = 0; i < ws.length; ++i) {\n                    ForkJoinWorkerThread t = ws[i];\n                    if (t != null)\n                        t.shutdownNow();\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Interrupt all unterminated workers.  This is not required for\n     * sake of internal control, but may help unstick user code during\n     * shutdown.\n     */\n    private void interruptUnterminatedWorkers() {\n        final ReentrantLock lock = this.workerLock;\n        lock.lock();\n        try {\n            ForkJoinWorkerThread[] ws = workers;\n            if (ws != null) {\n                for (int i = 0; i < ws.length; ++i) {\n                    ForkJoinWorkerThread t = ws[i];\n                    if (t != null && !t.isTerminated()) {\n                        try {\n                            t.interrupt();\n                        } catch (SecurityException ignore) {\n                        }\n                    }\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n\n\n    /*\n     * Nodes for event barrier to manage idle threads.  Queue nodes\n     * are basic Treiber stack nodes, also used for spare stack.\n     *\n     * The event barrier has an event count and a wait queue (actually\n     * a Treiber stack).  Workers are enabled to look for work when\n     * the eventCount is incremented. If they fail to find work, they\n     * may wait for next count. Upon release, threads help others wake\n     * up.\n     *\n     * Synchronization events occur only in enough contexts to\n     * maintain overall liveness:\n     *\n     *   - Submission of a new task to the pool\n     *   - Resizes or other changes to the workers array\n     *   - pool termination\n     *   - A worker pushing a task on an empty queue\n     *\n     * The case of pushing a task occurs often enough, and is heavy\n     * enough compared to simple stack pushes, to require special\n     * handling: Method signalWork returns without advancing count if\n     * the queue appears to be empty.  This would ordinarily result in\n     * races causing some queued waiters not to be woken up. To avoid\n     * this, the first worker enqueued in method sync (see\n     * syncIsReleasable) rescans for tasks after being enqueued, and\n     * helps signal if any are found. This works well because the\n     * worker has nothing better to do, and so might as well help\n     * alleviate the overhead and contention on the threads actually\n     * doing work.  Also, since event counts increments on task\n     * availability exist to maintain liveness (rather than to force\n     * refreshes etc), it is OK for callers to exit early if\n     * contending with another signaller.\n     */\n    static final class WaitQueueNode {\n        WaitQueueNode next; // only written before enqueued\n        volatile ForkJoinWorkerThread thread; // nulled to cancel wait\n        final long count; // unused for spare stack\n\n        WaitQueueNode(long c, ForkJoinWorkerThread w) {\n            count = c;\n            thread = w;\n        }\n\n        /**\n         * Wake up waiter, returning false if known to already\n         */\n        boolean signal() {\n            ForkJoinWorkerThread t = thread;\n            if (t == null)\n                return false;\n            thread = null;\n            LockSupport.unpark(t);\n            return true;\n        }\n\n        /**\n         * Await release on sync\n         */\n        void awaitSyncRelease(ForkJoinPool p) {\n            while (thread != null && !p.syncIsReleasable(this))\n                LockSupport.park(this);\n        }\n\n        /**\n         * Await resumption as spare\n         */\n        void awaitSpareRelease() {\n            while (thread != null) {\n                if (!Thread.interrupted())\n                    LockSupport.park(this);\n            }\n        }\n    }\n\n    /**\n     * Ensures that no thread is waiting for count to advance from the\n     * current value of eventCount read on entry to this method, by\n     * releasing waiting threads if necessary.\n     * @return the count\n     */\n    final long ensureSync() {\n        long c = eventCount;\n        WaitQueueNode q;\n        while ((q = syncStack) != null && q.count < c) {\n            if (casBarrierStack(q, null)) {\n                do {\n                    q.signal();\n                } while ((q = q.next) != null);\n                break;\n            }\n        }\n        return c;\n    }\n\n    /**\n     * Increments event count and releases waiting threads.\n     */\n    private void signalIdleWorkers() {\n        long c;\n        do;while (!casEventCount(c = eventCount, c+1));\n        ensureSync();\n    }\n\n    /**\n     * Signal threads waiting to poll a task. Because method sync\n     * rechecks availability, it is OK to only proceed if queue\n     * appears to be non-empty, and OK to skip under contention to\n     * increment count (since some other thread succeeded).\n     */\n    final void signalWork() {\n        long c;\n        WaitQueueNode q;\n        if (syncStack != null &&\n            casEventCount(c = eventCount, c+1) &&\n            (((q = syncStack) != null && q.count <= c) &&\n             (!casBarrierStack(q, q.next) || !q.signal())))\n            ensureSync();\n    }\n\n    /**\n     * Waits until event count advances from last value held by\n     * caller, or if excess threads, caller is resumed as spare, or\n     * caller or pool is terminating. Updates caller's event on exit.\n     * @param w the calling worker thread\n     */\n    final void sync(ForkJoinWorkerThread w) {\n        updateStealCount(w); // Transfer w's count while it is idle\n\n        while (!w.isShutdown() && !isTerminating() && !suspendIfSpare(w)) {\n            long prev = w.lastEventCount;\n            WaitQueueNode node = null;\n            WaitQueueNode h;\n            while (eventCount == prev &&\n                   ((h = syncStack) == null || h.count == prev)) {\n                if (node == null)\n                    node = new WaitQueueNode(prev, w);\n                if (casBarrierStack(node.next = h, node)) {\n                    node.awaitSyncRelease(this);\n                    break;\n                }\n            }\n            long ec = ensureSync();\n            if (ec != prev) {\n                w.lastEventCount = ec;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Returns true if worker waiting on sync can proceed:\n     *  - on signal (thread == null)\n     *  - on event count advance (winning race to notify vs signaller)\n     *  - on Interrupt\n     *  - if the first queued node, we find work available\n     * If node was not signalled and event count not advanced on exit,\n     * then we also help advance event count.\n     * @return true if node can be released\n     */\n    final boolean syncIsReleasable(WaitQueueNode node) {\n        long prev = node.count;\n        if (!Thread.interrupted() && node.thread != null &&\n            (node.next != null ||\n             !ForkJoinWorkerThread.hasQueuedTasks(workers)) &&\n            eventCount == prev)\n            return false;\n        if (node.thread != null) {\n            node.thread = null;\n            long ec = eventCount;\n            if (prev <= ec) // help signal\n                casEventCount(ec, ec+1);\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if a new sync event occurred since last call to\n     * sync or this method, if so, updating caller's count.\n     */\n    final boolean hasNewSyncEvent(ForkJoinWorkerThread w) {\n        long lc = w.lastEventCount;\n        long ec = ensureSync();\n        if (ec == lc)\n            return false;\n        w.lastEventCount = ec;\n        return true;\n    }\n\n    //  Parallelism maintenance\n\n    /**\n     * Decrement running count; if too low, add spare.\n     *\n     * Conceptually, all we need to do here is add or resume a\n     * spare thread when one is about to block (and remove or\n     * suspend it later when unblocked -- see suspendIfSpare).\n     * However, implementing this idea requires coping with\n     * several problems: We have imperfect information about the\n     * states of threads. Some count updates can and usually do\n     * lag run state changes, despite arrangements to keep them\n     * accurate (for example, when possible, updating counts\n     * before signalling or resuming), especially when running on\n     * dynamic JVMs that don't optimize the infrequent paths that\n     * update counts. Generating too many threads can make these\n     * problems become worse, because excess threads are more\n     * likely to be context-switched with others, slowing them all\n     * down, especially if there is no work available, so all are\n     * busy scanning or idling.  Also, excess spare threads can\n     * only be suspended or removed when they are idle, not\n     * immediately when they aren't needed. So adding threads will\n     * raise parallelism level for longer than necessary.  Also,\n     * FJ applications often enounter highly transient peaks when\n     * many threads are blocked joining, but for less time than it\n     * takes to create or resume spares.\n     *\n     * @param joinMe if non-null, return early if done\n     * @param maintainParallelism if true, try to stay within\n     * target counts, else create only to avoid starvation\n     * @return true if joinMe known to be done\n     */\n    final boolean preJoin(ForkJoinTask<?> joinMe, boolean maintainParallelism) {\n        maintainParallelism &= maintainsParallelism; // overrride\n        boolean dec = false;  // true when running count decremented\n        while (spareStack == null || !tryResumeSpare(dec)) {\n            int counts = workerCounts;\n            if (dec || (dec = casWorkerCounts(counts, --counts))) { // CAS cheat\n                if (!needSpare(counts, maintainParallelism))\n                    break;\n                if (joinMe.status < 0)\n                    return true;\n                if (tryAddSpare(counts))\n                    break;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Same idea as preJoin\n     */\n    final boolean preBlock(ManagedBlocker blocker, boolean maintainParallelism){\n        maintainParallelism &= maintainsParallelism;\n        boolean dec = false;\n        while (spareStack == null || !tryResumeSpare(dec)) {\n            int counts = workerCounts;\n            if (dec || (dec = casWorkerCounts(counts, --counts))) {\n                if (!needSpare(counts, maintainParallelism))\n                    break;\n                if (blocker.isReleasable())\n                    return true;\n                if (tryAddSpare(counts))\n                    break;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if a spare thread appears to be needed.  If\n     * maintaining parallelism, returns true when the deficit in\n     * running threads is more than the surplus of total threads, and\n     * there is apparently some work to do.  This self-limiting rule\n     * means that the more threads that have already been added, the\n     * less parallelism we will tolerate before adding another.\n     * @param counts current worker counts\n     * @param maintainParallelism try to maintain parallelism\n     */\n    private boolean needSpare(int counts, boolean maintainParallelism) {\n        int ps = parallelism;\n        int rc = runningCountOf(counts);\n        int tc = totalCountOf(counts);\n        int runningDeficit = ps - rc;\n        int totalSurplus = tc - ps;\n        return (tc < maxPoolSize &&\n                (rc == 0 || totalSurplus < 0 ||\n                 (maintainParallelism &&\n                  runningDeficit > totalSurplus &&\n                  ForkJoinWorkerThread.hasQueuedTasks(workers))));\n    }\n\n    /**\n     * Add a spare worker if lock available and no more than the\n     * expected numbers of threads exist\n     * @return true if successful\n     */\n    private boolean tryAddSpare(int expectedCounts) {\n        final ReentrantLock lock = this.workerLock;\n        int expectedRunning = runningCountOf(expectedCounts);\n        int expectedTotal = totalCountOf(expectedCounts);\n        boolean success = false;\n        boolean locked = false;\n        // confirm counts while locking; CAS after obtaining lock\n        try {\n            for (;;) {\n                int s = workerCounts;\n                int tc = totalCountOf(s);\n                int rc = runningCountOf(s);\n                if (rc > expectedRunning || tc > expectedTotal)\n                    break;\n                if (!locked && !(locked = lock.tryLock()))\n                    break;\n                if (casWorkerCounts(s, workerCountsFor(tc+1, rc+1))) {\n                    createAndStartSpare(tc);\n                    success = true;\n                    break;\n                }\n            }\n        } finally {\n            if (locked)\n                lock.unlock();\n        }\n        return success;\n    }\n\n    /**\n     * Add the kth spare worker. On entry, pool coounts are already\n     * adjusted to reflect addition.\n     */\n    private void createAndStartSpare(int k) {\n        ForkJoinWorkerThread w = null;\n        ForkJoinWorkerThread[] ws = ensureWorkerArrayCapacity(k + 1);\n        int len = ws.length;\n        // Probably, we can place at slot k. If not, find empty slot\n        if (k < len && ws[k] != null) {\n            for (k = 0; k < len && ws[k] != null; ++k)\n                ;\n        }\n        if (k < len && !isTerminating() && (w = createWorker(k)) != null) {\n            ws[k] = w;\n            w.start();\n        }\n        else\n            updateWorkerCount(-1); // adjust on failure\n        signalIdleWorkers();\n    }\n\n    /**\n     * Suspend calling thread w if there are excess threads.  Called\n     * only from sync.  Spares are enqueued in a Treiber stack\n     * using the same WaitQueueNodes as barriers.  They are resumed\n     * mainly in preJoin, but are also woken on pool events that\n     * require all threads to check run state.\n     * @param w the caller\n     */\n    private boolean suspendIfSpare(ForkJoinWorkerThread w) {\n        WaitQueueNode node = null;\n        int s;\n        while (parallelism < runningCountOf(s = workerCounts)) {\n            if (node == null)\n                node = new WaitQueueNode(0, w);\n            if (casWorkerCounts(s, s-1)) { // representation-dependent\n                // push onto stack\n                do;while (!casSpareStack(node.next = spareStack, node));\n                // block until released by resumeSpare\n                node.awaitSpareRelease();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Try to pop and resume a spare thread.\n     * @param updateCount if true, increment running count on success\n     * @return true if successful\n     */\n    private boolean tryResumeSpare(boolean updateCount) {\n        WaitQueueNode q;\n        while ((q = spareStack) != null) {\n            if (casSpareStack(q, q.next)) {\n                if (updateCount)\n                    updateRunningCount(1);\n                q.signal();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Pop and resume all spare threads. Same idea as ensureSync.\n     * @return true if any spares released\n     */\n    private boolean resumeAllSpares() {\n        WaitQueueNode q;\n        while ( (q = spareStack) != null) {\n            if (casSpareStack(q, null)) {\n                do {\n                    updateRunningCount(1);\n                    q.signal();\n                } while ((q = q.next) != null);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Pop and shutdown excessive spare threads. Call only while\n     * holding lock. This is not guaranteed to eliminate all excess\n     * threads, only those suspended as spares, which are the ones\n     * unlikely to be needed in the future.\n     */\n    private void trimSpares() {\n        int surplus = totalCountOf(workerCounts) - parallelism;\n        WaitQueueNode q;\n        while (surplus > 0 && (q = spareStack) != null) {\n            if (casSpareStack(q, null)) {\n                do {\n                    updateRunningCount(1);\n                    ForkJoinWorkerThread w = q.thread;\n                    if (w != null && surplus > 0 &&\n                        runningCountOf(workerCounts) > 0 && w.shutdown())\n                        --surplus;\n                    q.signal();\n                } while ((q = q.next) != null);\n            }\n        }\n    }\n\n    /**\n     * Interface for extending managed parallelism for tasks running\n     * in ForkJoinPools. A ManagedBlocker provides two methods.\n     * Method <code>isReleasable</code> must return true if blocking is not\n     * necessary. Method <code>block</code> blocks the current thread\n     * if necessary (perhaps internally invoking isReleasable before\n     * actually blocking.).\n     * <p>For example, here is a ManagedBlocker based on a\n     * ReentrantLock:\n     * <pre>\n     *   class ManagedLocker implements ManagedBlocker {\n     *     final ReentrantLock lock;\n     *     boolean hasLock = false;\n     *     ManagedLocker(ReentrantLock lock) { this.lock = lock; }\n     *     public boolean block() {\n     *        if (!hasLock)\n     *           lock.lock();\n     *        return true;\n     *     }\n     *     public boolean isReleasable() {\n     *        return hasLock || (hasLock = lock.tryLock());\n     *     }\n     *   }\n     * </pre>\n     */\n    public static interface ManagedBlocker {\n        /**\n         * Possibly blocks the current thread, for example waiting for\n         * a lock or condition.\n         * @return true if no additional blocking is necessary (i.e.,\n         * if isReleasable would return true).\n         * @throws InterruptedException if interrupted while waiting\n         * (the method is not required to do so, but is allowe to).\n         */\n        boolean block() throws InterruptedException;\n\n        /**\n         * Returns true if blocking is unnecessary.\n         */\n        boolean isReleasable();\n    }\n\n    /**\n     * Blocks in accord with the given blocker.  If the current thread\n     * is a ForkJoinWorkerThread, this method possibly arranges for a\n     * spare thread to be activated if necessary to ensure parallelism\n     * while the current thread is blocked.  If\n     * <code>maintainParallelism</code> is true and the pool supports\n     * it ({@link #getMaintainsParallelism}), this method attempts to\n     * maintain the pool's nominal parallelism. Otherwise if activates\n     * a thread only if necessary to avoid complete starvation. This\n     * option may be preferable when blockages use timeouts, or are\n     * almost always brief.\n     *\n     * <p> If the caller is not a ForkJoinTask, this method is behaviorally\n     * equivalent to\n     * <pre>\n     *   while (!blocker.isReleasable())\n     *      if (blocker.block())\n     *         return;\n     * </pre>\n     * If the caller is a ForkJoinTask, then the pool may first\n     * be expanded to ensure parallelism, and later adjusted.\n     *\n     * @param blocker the blocker\n     * @param maintainParallelism if true and supported by this pool,\n     * attempt to maintain the pool's nominal parallelism; otherwise\n     * activate a thread only if necessary to avoid complete\n     * starvation.\n     * @throws InterruptedException if blocker.block did so.\n     */\n    public static void managedBlock(ManagedBlocker blocker,\n                                    boolean maintainParallelism)\n        throws InterruptedException {\n        Thread t = Thread.currentThread();\n        ForkJoinPool pool = (t instanceof ForkJoinWorkerThread?\n                             ((ForkJoinWorkerThread)t).pool : null);\n        if (!blocker.isReleasable()) {\n            try {\n                if (pool == null ||\n                    !pool.preBlock(blocker, maintainParallelism))\n                    awaitBlocker(blocker);\n            } finally {\n                if (pool != null)\n                    pool.updateRunningCount(1);\n            }\n        }\n    }\n\n    private static void awaitBlocker(ManagedBlocker blocker)\n        throws InterruptedException {\n        do;while (!blocker.isReleasable() && !blocker.block());\n    }\n\n    // AbstractExecutorService overrides\n\n    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n        return new AdaptedRunnable(runnable, value);\n    }\n\n    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n        return new AdaptedCallable(callable);\n    }\n\n\n    // Temporary Unsafe mechanics for preliminary release\n    private static Unsafe getUnsafe() throws Throwable {\n        try {\n            return Unsafe.getUnsafe();\n        } catch (SecurityException se) {\n            try {\n                return java.security.AccessController.doPrivileged\n                    (new java.security.PrivilegedExceptionAction<Unsafe>() {\n                        public Unsafe run() throws Exception {\n                            return getUnsafePrivileged();\n                        }});\n            } catch (java.security.PrivilegedActionException e) {\n                throw e.getCause();\n            }\n        }\n    }\n\n    private static Unsafe getUnsafePrivileged()\n            throws NoSuchFieldException, IllegalAccessException {\n        Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (Unsafe) f.get(null);\n    }\n\n    private static long fieldOffset(String fieldName)\n            throws NoSuchFieldException {\n        return _unsafe.objectFieldOffset\n            (ForkJoinPool.class.getDeclaredField(fieldName));\n    }\n\n    static final Unsafe _unsafe;\n    static final long eventCountOffset;\n    static final long workerCountsOffset;\n    static final long runControlOffset;\n    static final long syncStackOffset;\n    static final long spareStackOffset;\n\n    static {\n        try {\n            _unsafe = getUnsafe();\n            eventCountOffset = fieldOffset(\"eventCount\");\n            workerCountsOffset = fieldOffset(\"workerCounts\");\n            runControlOffset = fieldOffset(\"runControl\");\n            syncStackOffset = fieldOffset(\"syncStack\");\n            spareStackOffset = fieldOffset(\"spareStack\");\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not initialize intrinsics\", e);\n        }\n    }\n\n    private boolean casEventCount(long cmp, long val) {\n        return _unsafe.compareAndSwapLong(this, eventCountOffset, cmp, val);\n    }\n    private boolean casWorkerCounts(int cmp, int val) {\n        return _unsafe.compareAndSwapInt(this, workerCountsOffset, cmp, val);\n    }\n    private boolean casRunControl(int cmp, int val) {\n        return _unsafe.compareAndSwapInt(this, runControlOffset, cmp, val);\n    }\n    private boolean casSpareStack(WaitQueueNode cmp, WaitQueueNode val) {\n        return _unsafe.compareAndSwapObject(this, spareStackOffset, cmp, val);\n    }\n    private boolean casBarrierStack(WaitQueueNode cmp, WaitQueueNode val) {\n        return _unsafe.compareAndSwapObject(this, syncStackOffset, cmp, val);\n    }\n}\n"},{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"getUnsafe","lines":[[725,26,35]]}]}],"score":387,"fileName":"scala/legacy-svn-scala/blob/master/src/forkjoin/scala/concurrent/forkjoin/ForkJoinWorkerThread.java","fileContent":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/licenses/publicdomain\n */\n\npackage scala.concurrent.forkjoin;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\nimport java.util.concurrent.locks.*;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.*;\n\n/**\n * A thread managed by a {@link ForkJoinPool}.  This class is\n * subclassable solely for the sake of adding functionality -- there\n * are no overridable methods dealing with scheduling or\n * execution. However, you can override initialization and termination\n * methods surrounding the main task processing loop.  If you do\n * create such a subclass, you will also need to supply a custom\n * ForkJoinWorkerThreadFactory to use it in a ForkJoinPool.\n *\n */\npublic class ForkJoinWorkerThread extends Thread {\n    /*\n     * Algorithm overview:\n     *\n     * 1. Work-Stealing: Work-stealing queues are special forms of\n     * Deques that support only three of the four possible\n     * end-operations -- push, pop, and deq (aka steal), and only do\n     * so under the constraints that push and pop are called only from\n     * the owning thread, while deq may be called from other threads.\n     * (If you are unfamiliar with them, you probably want to read\n     * Herlihy and Shavit's book \"The Art of Multiprocessor\n     * programming\", chapter 16 describing these in more detail before\n     * proceeding.)  The main work-stealing queue design is roughly\n     * similar to \"Dynamic Circular Work-Stealing Deque\" by David\n     * Chase and Yossi Lev, SPAA 2005\n     * (http://research.sun.com/scalable/pubs/index.html).  The main\n     * difference ultimately stems from gc requirements that we null\n     * out taken slots as soon as we can, to maintain as small a\n     * footprint as possible even in programs generating huge numbers\n     * of tasks. To accomplish this, we shift the CAS arbitrating pop\n     * vs deq (steal) from being on the indices (\"base\" and \"sp\") to\n     * the slots themselves (mainly via method \"casSlotNull()\"). So,\n     * both a successful pop and deq mainly entail CAS'ing a nonnull\n     * slot to null.  Because we rely on CASes of references, we do\n     * not need tag bits on base or sp.  They are simple ints as used\n     * in any circular array-based queue (see for example ArrayDeque).\n     * Updates to the indices must still be ordered in a way that\n     * guarantees that (sp - base) > 0 means the queue is empty, but\n     * otherwise may err on the side of possibly making the queue\n     * appear nonempty when a push, pop, or deq have not fully\n     * committed. Note that this means that the deq operation,\n     * considered individually, is not wait-free. One thief cannot\n     * successfully continue until another in-progress one (or, if\n     * previously empty, a push) completes.  However, in the\n     * aggregate, we ensure at least probablistic non-blockingness. If\n     * an attempted steal fails, a thief always chooses a different\n     * random victim target to try next. So, in order for one thief to\n     * progress, it suffices for any in-progress deq or new push on\n     * any empty queue to complete. One reason this works well here is\n     * that apparently-nonempty often means soon-to-be-stealable,\n     * which gives threads a chance to activate if necessary before\n     * stealing (see below).\n     *\n     * Efficient implementation of this approach currently relies on\n     * an uncomfortable amount of \"Unsafe\" mechanics. To maintain\n     * correct orderings, reads and writes of variable base require\n     * volatile ordering.  Variable sp does not require volatile write\n     * but needs cheaper store-ordering on writes.  Because they are\n     * protected by volatile base reads, reads of the queue array and\n     * its slots do not need volatile load semantics, but writes (in\n     * push) require store order and CASes (in pop and deq) require\n     * (volatile) CAS semantics. Since these combinations aren't\n     * supported using ordinary volatiles, the only way to accomplish\n     * these effciently is to use direct Unsafe calls. (Using external\n     * AtomicIntegers and AtomicReferenceArrays for the indices and\n     * array is significantly slower because of memory locality and\n     * indirection effects.) Further, performance on most platforms is\n     * very sensitive to placement and sizing of the (resizable) queue\n     * array.  Even though these queues don't usually become all that\n     * big, the initial size must be large enough to counteract cache\n     * contention effects across multiple queues (especially in the\n     * presence of GC cardmarking). Also, to improve thread-locality,\n     * queues are currently initialized immediately after the thread\n     * gets the initial signal to start processing tasks.  However,\n     * all queue-related methods except pushTask are written in a way\n     * that allows them to instead be lazily allocated and/or disposed\n     * of when empty. All together, these low-level implementation\n     * choices produce as much as a factor of 4 performance\n     * improvement compared to naive implementations, and enable the\n     * processing of billions of tasks per second, sometimes at the\n     * expense of ugliness.\n     *\n     * 2. Run control: The primary run control is based on a global\n     * counter (activeCount) held by the pool. It uses an algorithm\n     * similar to that in Herlihy and Shavit section 17.6 to cause\n     * threads to eventually block when all threads declare they are\n     * inactive. (See variable \"scans\".)  For this to work, threads\n     * must be declared active when executing tasks, and before\n     * stealing a task. They must be inactive before blocking on the\n     * Pool Barrier (awaiting a new submission or other Pool\n     * event). In between, there is some free play which we take\n     * advantage of to avoid contention and rapid flickering of the\n     * global activeCount: If inactive, we activate only if a victim\n     * queue appears to be nonempty (see above).  Similarly, a thread\n     * tries to inactivate only after a full scan of other threads.\n     * The net effect is that contention on activeCount is rarely a\n     * measurable performance issue. (There are also a few other cases\n     * where we scan for work rather than retry/block upon\n     * contention.)\n     *\n     * 3. Selection control. We maintain policy of always choosing to\n     * run local tasks rather than stealing, and always trying to\n     * steal tasks before trying to run a new submission. All steals\n     * are currently performed in randomly-chosen deq-order. It may be\n     * worthwhile to bias these with locality / anti-locality\n     * information, but doing this well probably requires more\n     * lower-level information from JVMs than currently provided.\n     */\n\n    /**\n     * Capacity of work-stealing queue array upon initialization.\n     * Must be a power of two. Initial size must be at least 2, but is\n     * padded to minimize cache effects.\n     */\n    private static final int INITIAL_QUEUE_CAPACITY = 1 << 13;\n\n    /**\n     * Maximum work-stealing queue array size.  Must be less than or\n     * equal to 1 << 28 to ensure lack of index wraparound. (This\n     * is less than usual bounds, because we need leftshift by 3\n     * to be in int range).\n     */\n    private static final int MAXIMUM_QUEUE_CAPACITY = 1 << 28;\n\n    /**\n     * The pool this thread works in. Accessed directly by ForkJoinTask\n     */\n    final ForkJoinPool pool;\n\n    /**\n     * The work-stealing queue array. Size must be a power of two.\n     * Initialized when thread starts, to improve memory locality.\n     */\n    private ForkJoinTask<?>[] queue;\n\n    /**\n     * Index (mod queue.length) of next queue slot to push to or pop\n     * from. It is written only by owner thread, via ordered store.\n     * Both sp and base are allowed to wrap around on overflow, but\n     * (sp - base) still estimates size.\n     */\n    private volatile int sp;\n\n    /**\n     * Index (mod queue.length) of least valid queue slot, which is\n     * always the next position to steal from if nonempty.\n     */\n    private volatile int base;\n\n    /**\n     * Activity status. When true, this worker is considered active.\n     * Must be false upon construction. It must be true when executing\n     * tasks, and BEFORE stealing a task. It must be false before\n     * calling pool.sync\n     */\n    private boolean active;\n\n    /**\n     * Run state of this worker. Supports simple versions of the usual\n     * shutdown/shutdownNow control.\n     */\n    private volatile int runState;\n\n    /**\n     * Seed for random number generator for choosing steal victims.\n     * Uses Marsaglia xorshift. Must be nonzero upon initialization.\n     */\n    private int seed;\n\n    /**\n     * Number of steals, transferred to pool when idle\n     */\n    private int stealCount;\n\n    /**\n     * Index of this worker in pool array. Set once by pool before\n     * running, and accessed directly by pool during cleanup etc\n     */\n    int poolIndex;\n\n    /**\n     * The last barrier event waited for. Accessed in pool callback\n     * methods, but only by current thread.\n     */\n    long lastEventCount;\n\n    /**\n     * True if use local fifo, not default lifo, for local polling\n     */\n    private boolean locallyFifo;\n\n    /**\n     * Creates a ForkJoinWorkerThread operating in the given pool.\n     * @param pool the pool this thread works in\n     * @throws NullPointerException if pool is null\n     */\n    protected ForkJoinWorkerThread(ForkJoinPool pool) {\n        if (pool == null) throw new NullPointerException();\n        this.pool = pool;\n        // Note: poolIndex is set by pool during construction\n        // Remaining initialization is deferred to onStart\n    }\n\n    // Public access methods\n\n    /**\n     * Returns the pool hosting this thread\n     * @return the pool\n     */\n    public ForkJoinPool getPool() {\n        return pool;\n    }\n\n    /**\n     * Returns the index number of this thread in its pool.  The\n     * returned value ranges from zero to the maximum number of\n     * threads (minus one) that have ever been created in the pool.\n     * This method may be useful for applications that track status or\n     * collect results per-worker rather than per-task.\n     * @return the index number.\n     */\n    public int getPoolIndex() {\n        return poolIndex;\n    }\n\n    /**\n     * Establishes local first-in-first-out scheduling mode for forked\n     * tasks that are never joined. \n     * @param async if true, use locally FIFO scheduling\n     */\n    void setAsyncMode(boolean async) {\n        locallyFifo = async;\n    }\n\n    // Runstate management\n\n    // Runstate values. Order matters\n    private static final int RUNNING     = 0;\n    private static final int SHUTDOWN    = 1;\n    private static final int TERMINATING = 2;\n    private static final int TERMINATED  = 3;\n\n    final boolean isShutdown()    { return runState >= SHUTDOWN;  }\n    final boolean isTerminating() { return runState >= TERMINATING;  }\n    final boolean isTerminated()  { return runState == TERMINATED; }\n    final boolean shutdown()      { return transitionRunStateTo(SHUTDOWN); }\n    final boolean shutdownNow()   { return transitionRunStateTo(TERMINATING); }\n\n    /**\n     * Transition to at least the given state. Return true if not\n     * already at least given state.\n     */\n    private boolean transitionRunStateTo(int state) {\n        for (;;) {\n            int s = runState;\n            if (s >= state)\n                return false;\n            if (_unsafe.compareAndSwapInt(this, runStateOffset, s, state))\n                return true;\n        }\n    }\n\n    /**\n     * Try to set status to active; fail on contention\n     */\n    private boolean tryActivate() {\n        if (!active) {\n            if (!pool.tryIncrementActiveCount())\n                return false;\n            active = true;\n        }\n        return true;\n    }\n\n    /**\n     * Try to set status to active; fail on contention\n     */\n    private boolean tryInactivate() {\n        if (active) {\n            if (!pool.tryDecrementActiveCount())\n                return false;\n            active = false;\n        }\n        return true;\n    }\n\n    /**\n     * Computes next value for random victim probe. Scans don't\n     * require a very high quality generator, but also not a crummy\n     * one. Marsaglia xor-shift is cheap and works well.\n     */\n    private static int xorShift(int r) {\n        r ^= r << 1;\n        r ^= r >>> 3;\n        r ^= r << 10;\n        return r;\n    }\n\n    // Lifecycle methods\n\n    /**\n     * This method is required to be public, but should never be\n     * called explicitly. It performs the main run loop to execute\n     * ForkJoinTasks.\n     */\n    public void run() {\n        Throwable exception = null;\n        try {\n            onStart();\n            pool.sync(this); // await first pool event\n            mainLoop();\n        } catch (Throwable ex) {\n            exception = ex;\n        } finally {\n            onTermination(exception);\n        }\n    }\n\n    /**\n     * Execute tasks until shut down.\n     */\n    private void mainLoop() {\n        while (!isShutdown()) {\n            ForkJoinTask<?> t = pollTask();\n            if (t != null || (t = pollSubmission()) != null)\n                t.quietlyExec();\n            else if (tryInactivate())\n                pool.sync(this);\n        }\n    }\n\n    /**\n     * Initializes internal state after construction but before\n     * processing any tasks. If you override this method, you must\n     * invoke super.onStart() at the beginning of the method.\n     * Initialization requires care: Most fields must have legal\n     * default values, to ensure that attempted accesses from other\n     * threads work correctly even before this thread starts\n     * processing tasks.\n     */\n    protected void onStart() {\n        // Allocate while starting to improve chances of thread-local\n        // isolation\n        queue = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n        // Initial value of seed need not be especially random but\n        // should differ across workers and must be nonzero\n        int p = poolIndex + 1;\n        seed = p + (p << 8) + (p << 16) + (p << 24); // spread bits\n    }\n\n    /**\n     * Perform cleanup associated with termination of this worker\n     * thread.  If you override this method, you must invoke\n     * super.onTermination at the end of the overridden method.\n     *\n     * @param exception the exception causing this thread to abort due\n     * to an unrecoverable error, or null if completed normally.\n     */\n    protected void onTermination(Throwable exception) {\n        // Execute remaining local tasks unless aborting or terminating\n        while (exception == null &&  !pool.isTerminating() && base != sp) {\n            try {\n                ForkJoinTask<?> t = popTask();\n                if (t != null)\n                    t.quietlyExec();\n            } catch(Throwable ex) {\n                exception = ex;\n            }\n        }\n        // Cancel other tasks, transition status, notify pool, and\n        // propagate exception to uncaught exception handler\n        try {\n            do;while (!tryInactivate()); // ensure inactive\n            cancelTasks();\n            runState = TERMINATED;\n            pool.workerTerminated(this);\n        } catch (Throwable ex) {        // Shouldn't ever happen\n            if (exception == null)      // but if so, at least rethrown\n                exception = ex;\n        } finally {\n            if (exception != null)\n                ForkJoinTask.rethrowException(exception);\n        }\n    }\n\n    // Intrinsics-based support for queue operations.\n\n    /**\n     * Add in store-order the given task at given slot of q to\n     * null. Caller must ensure q is nonnull and index is in range.\n     */\n    private static void setSlot(ForkJoinTask<?>[] q, int i,\n                                ForkJoinTask<?> t){\n        _unsafe.putOrderedObject(q, (i << qShift) + qBase, t);\n    }\n\n    /**\n     * CAS given slot of q to null. Caller must ensure q is nonnull\n     * and index is in range.\n     */\n    private static boolean casSlotNull(ForkJoinTask<?>[] q, int i,\n                                       ForkJoinTask<?> t) {\n        return _unsafe.compareAndSwapObject(q, (i << qShift) + qBase, t, null);\n    }\n\n    /**\n     * Sets sp in store-order.\n     */\n    private void storeSp(int s) {\n        _unsafe.putOrderedInt(this, spOffset, s);\n    }\n\n    // Main queue methods\n\n    /**\n     * Pushes a task. Called only by current thread.\n     * @param t the task. Caller must ensure nonnull\n     */\n    final void pushTask(ForkJoinTask<?> t) {\n        ForkJoinTask<?>[] q = queue;\n        int mask = q.length - 1;\n        int s = sp;\n        setSlot(q, s & mask, t);\n        storeSp(++s);\n        if ((s -= base) == 1)\n            pool.signalWork();\n        else if (s >= mask)\n            growQueue();\n    }\n\n    /**\n     * Tries to take a task from the base of the queue, failing if\n     * either empty or contended.\n     * @return a task, or null if none or contended.\n     */\n    final ForkJoinTask<?> deqTask() {\n        ForkJoinTask<?> t;\n        ForkJoinTask<?>[] q;\n        int i;\n        int b;\n        if (sp != (b = base) &&\n            (q = queue) != null && // must read q after b\n            (t = q[i = (q.length - 1) & b]) != null &&\n            casSlotNull(q, i, t)) {\n            base = b + 1;\n            return t;\n        }\n        return null;\n    }\n\n    /**\n     * Returns a popped task, or null if empty. Ensures active status\n     * if nonnull. Called only by current thread.\n     */\n    final ForkJoinTask<?> popTask() {\n        int s = sp;\n        while (s != base) {\n            if (tryActivate()) {\n                ForkJoinTask<?>[] q = queue;\n                int mask = q.length - 1;\n                int i = (s - 1) & mask;\n                ForkJoinTask<?> t = q[i];\n                if (t == null || !casSlotNull(q, i, t))\n                    break;\n                storeSp(s - 1);\n                return t;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Specialized version of popTask to pop only if\n     * topmost element is the given task. Called only\n     * by current thread while active.\n     * @param t the task. Caller must ensure nonnull\n     */\n    final boolean unpushTask(ForkJoinTask<?> t) {\n        ForkJoinTask<?>[] q = queue;\n        int mask = q.length - 1;\n        int s = sp - 1;\n        if (casSlotNull(q, s & mask, t)) {\n            storeSp(s);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Returns next task.\n     */\n    final ForkJoinTask<?> peekTask() {\n        ForkJoinTask<?>[] q = queue;\n        if (q == null)\n            return null;\n        int mask = q.length - 1;\n        int i = locallyFifo? base : (sp - 1);\n        return q[i & mask];\n    }\n\n    /**\n     * Doubles queue array size. Transfers elements by emulating\n     * steals (deqs) from old array and placing, oldest first, into\n     * new array.\n     */\n    private void growQueue() {\n        ForkJoinTask<?>[] oldQ = queue;\n        int oldSize = oldQ.length;\n        int newSize = oldSize << 1;\n        if (newSize > MAXIMUM_QUEUE_CAPACITY)\n            throw new RejectedExecutionException(\"Queue capacity exceeded\");\n        ForkJoinTask<?>[] newQ = queue = new ForkJoinTask<?>[newSize];\n\n        int b = base;\n        int bf = b + oldSize;\n        int oldMask = oldSize - 1;\n        int newMask = newSize - 1;\n        do {\n            int oldIndex = b & oldMask;\n            ForkJoinTask<?> t = oldQ[oldIndex];\n            if (t != null && !casSlotNull(oldQ, oldIndex, t))\n                t = null;\n            setSlot(newQ, b & newMask, t);\n        } while (++b != bf);\n        pool.signalWork();\n    }\n\n    /**\n     * Tries to steal a task from another worker. Starts at a random\n     * index of workers array, and probes workers until finding one\n     * with non-empty queue or finding that all are empty.  It\n     * randomly selects the first n probes. If these are empty, it\n     * resorts to a full circular traversal, which is necessary to\n     * accurately set active status by caller. Also restarts if pool\n     * events occurred since last scan, which forces refresh of\n     * workers array, in case barrier was associated with resize.\n     *\n     * This method must be both fast and quiet -- usually avoiding\n     * memory accesses that could disrupt cache sharing etc other than\n     * those needed to check for and take tasks. This accounts for,\n     * among other things, updating random seed in place without\n     * storing it until exit.\n     *\n     * @return a task, or null if none found\n     */\n    private ForkJoinTask<?> scan() {\n        ForkJoinTask<?> t = null;\n        int r = seed;                    // extract once to keep scan quiet\n        ForkJoinWorkerThread[] ws;       // refreshed on outer loop\n        int mask;                        // must be power 2 minus 1 and > 0\n        outer:do {\n            if ((ws = pool.workers) != null && (mask = ws.length - 1) > 0) {\n                int idx = r;\n                int probes = ~mask;      // use random index while negative\n                for (;;) {\n                    r = xorShift(r);     // update random seed\n                    ForkJoinWorkerThread v = ws[mask & idx];\n                    if (v == null || v.sp == v.base) {\n                        if (probes <= mask)\n                            idx = (probes++ < 0)? r : (idx + 1);\n                        else\n                            break;\n                    }\n                    else if (!tryActivate() || (t = v.deqTask()) == null)\n                        continue outer;  // restart on contention\n                    else\n                        break outer;\n                }\n            }\n        } while (pool.hasNewSyncEvent(this)); // retry on pool events\n        seed = r;\n        return t;\n    }\n\n    /**\n     * gets and removes a local or stolen a task\n     * @return a task, if available\n     */\n    final ForkJoinTask<?> pollTask() {\n        ForkJoinTask<?> t = locallyFifo? deqTask() : popTask();\n        if (t == null && (t = scan()) != null)\n            ++stealCount;\n        return t;\n    }\n\n    /**\n     * gets a local task\n     * @return a task, if available\n     */\n    final ForkJoinTask<?> pollLocalTask() {\n        return locallyFifo? deqTask() : popTask();\n    }\n\n    /**\n     * Returns a pool submission, if one exists, activating first.\n     * @return a submission, if available\n     */\n    private ForkJoinTask<?> pollSubmission() {\n        ForkJoinPool p = pool;\n        while (p.hasQueuedSubmissions()) {\n            ForkJoinTask<?> t;\n            if (tryActivate() && (t = p.pollSubmission()) != null)\n                return t;\n        }\n        return null;\n    }\n\n    // Methods accessed only by Pool\n\n    /**\n     * Removes and cancels all tasks in queue.  Can be called from any\n     * thread.\n     */\n    final void cancelTasks() {\n        ForkJoinTask<?> t;\n        while (base != sp && (t = deqTask()) != null)\n            t.cancelIgnoringExceptions();\n    }\n\n    /**\n     * Drains tasks to given collection c\n     * @return the number of tasks drained\n     */\n    final int drainTasksTo(Collection<ForkJoinTask<?>> c) {\n        int n = 0;\n        ForkJoinTask<?> t;\n        while (base != sp && (t = deqTask()) != null) {\n            c.add(t);\n            ++n;\n        }\n        return n;\n    }\n\n    /**\n     * Get and clear steal count for accumulation by pool.  Called\n     * only when known to be idle (in pool.sync and termination).\n     */\n    final int getAndClearStealCount() {\n        int sc = stealCount;\n        stealCount = 0;\n        return sc;\n    }\n\n    /**\n     * Returns true if at least one worker in the given array appears\n     * to have at least one queued task.\n     * @param ws array of workers\n     */\n    static boolean hasQueuedTasks(ForkJoinWorkerThread[] ws) {\n        if (ws != null) {\n            int len = ws.length;\n            for (int j = 0; j < 2; ++j) { // need two passes for clean sweep\n                for (int i = 0; i < len; ++i) {\n                    ForkJoinWorkerThread w = ws[i];\n                    if (w != null && w.sp != w.base)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    // Support methods for ForkJoinTask\n\n    /**\n     * Returns an estimate of the number of tasks in the queue.\n     */\n    final int getQueueSize() {\n        int n = sp - base;\n        return n < 0? 0 : n; // suppress momentarily negative values\n    }\n\n    /**\n     * Returns an estimate of the number of tasks, offset by a\n     * function of number of idle workers.\n     */\n    final int getEstimatedSurplusTaskCount() {\n        // The halving approximates weighting idle vs non-idle workers\n        return (sp - base) - (pool.getIdleThreadCount() >>> 1);\n    }\n\n    /**\n     * Scan, returning early if joinMe done\n     */\n    final ForkJoinTask<?> scanWhileJoining(ForkJoinTask<?> joinMe) {\n        ForkJoinTask<?> t = pollTask();\n        if (t != null && joinMe.status < 0 && sp == base) {\n            pushTask(t); // unsteal if done and this task would be stealable\n            t = null;\n        }\n        return t;\n    }\n\n    /**\n     * Runs tasks until pool isQuiescent\n     */\n    final void helpQuiescePool() {\n        for (;;) {\n            ForkJoinTask<?> t = pollTask();\n            if (t != null)\n                t.quietlyExec();\n            else if (tryInactivate() && pool.isQuiescent())\n                break;\n        }\n        do;while (!tryActivate()); // re-activate on exit\n    }\n\n    // Temporary Unsafe mechanics for preliminary release\n    private static Unsafe getUnsafe() throws Throwable {\n        try {\n            return Unsafe.getUnsafe();\n        } catch (SecurityException se) {\n            try {\n                return java.security.AccessController.doPrivileged\n                    (new java.security.PrivilegedExceptionAction<Unsafe>() {\n                        public Unsafe run() throws Exception {\n                            return getUnsafePrivileged();\n                        }});\n            } catch (java.security.PrivilegedActionException e) {\n                throw e.getCause();\n            }\n        }\n    }\n\n    private static Unsafe getUnsafePrivileged()\n            throws NoSuchFieldException, IllegalAccessException {\n        Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (Unsafe) f.get(null);\n    }\n\n    private static long fieldOffset(String fieldName)\n            throws NoSuchFieldException {\n        return _unsafe.objectFieldOffset\n            (ForkJoinWorkerThread.class.getDeclaredField(fieldName));\n    }\n\n    static final Unsafe _unsafe;\n    static final long baseOffset;\n    static final long spOffset;\n    static final long runStateOffset;\n    static final long qBase;\n    static final int qShift;\n    static {\n        try {\n            _unsafe = getUnsafe();\n            baseOffset = fieldOffset(\"base\");\n            spOffset = fieldOffset(\"sp\");\n            runStateOffset = fieldOffset(\"runState\");\n            qBase = _unsafe.arrayBaseOffset(ForkJoinTask[].class);\n            int s = _unsafe.arrayIndexScale(ForkJoinTask[].class);\n            if ((s & (s-1)) != 0)\n                throw new Error(\"data type scale not a power of two\");\n            qShift = 31 - Integer.numberOfLeadingZeros(s);\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not initialize intrinsics\", e);\n        }\n    }\n}\n"},{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"getUnsafe","lines":[[42,23,32],[29,19,28]]}]}],"score":45,"fileName":"CyanogenMod/android_libcore/blob/cm-13.0/luni/src/test/java/sun/misc/UnsafeTest.java","fileContent":"/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage sun.misc;\n\nimport junit.framework.TestCase;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Executors;\n\npublic class UnsafeTest extends TestCase {\n\n    public void test_getUnsafeForbidden() {\n        try {\n            Unsafe.getUnsafe();\n            fail();\n        } catch (SecurityException expected) {\n        }\n    }\n\n    /**\n     * Regression for 2053217. We used to look one level higher than necessary\n     * on the stack.\n     */\n    public void test_getUnsafeForbiddenWithSystemCaller() throws Exception {\n        Callable<Object> callable = Executors.callable(new Runnable() {\n            public void run() {\n                Unsafe.getUnsafe();\n            }\n        });\n\n        try {\n            callable.call();\n            fail();\n        } catch (SecurityException expected) {\n        }\n    }\n\n    private class AllocateInstanceTestClass {\n        public int i = 123;\n        public String s = \"hello\";\n        public Object getThis() { return AllocateInstanceTestClass.this; }\n    }\n\n    private static Unsafe getUnsafe() throws Exception {\n        Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n        Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (Unsafe) f.get(null);\n    }\n\n    public void test_allocateInstance() throws Exception {\n        AllocateInstanceTestClass i = (AllocateInstanceTestClass)\n                getUnsafe().allocateInstance(AllocateInstanceTestClass.class);\n        assertEquals(0, i.i);\n        assertEquals(null, i.s);\n        assertEquals(i, i.getThis());\n    }\n}\n"},{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"getUnsafe","lines":[[19,20,29]]}]}],"score":123,"fileName":"stephenc/high-scale-lib/blob/master/high-scale-lib/src/main/java/org/cliffc/high_scale_lib/UtilUnsafe.java","fileContent":"package org.cliffc.high_scale_lib;\r\nimport java.lang.reflect.Field;\r\nimport sun.misc.Unsafe;\r\n\r\n/**\r\n * Simple class to obtain access to the {@link Unsafe} object.  {@link Unsafe}\r\n * is required to allow efficient CAS operations on arrays.  Note that the\r\n * versions in {@link java.util.concurrent.atomic}, such as {@link\r\n * java.util.concurrent.atomic.AtomicLongArray}, require extra memory ordering\r\n * guarantees which are generally not needed in these algorithms and are also\r\n * expensive on most processors.\r\n */\r\nclass UtilUnsafe {\r\n  private UtilUnsafe() { } // dummy private constructor\r\n  /** Fetch the Unsafe.  Use With Caution. */\r\n  public static Unsafe getUnsafe() {\r\n    // Not on bootclasspath\r\n    if( UtilUnsafe.class.getClassLoader() == null )\r\n      return Unsafe.getUnsafe();\r\n    try {\r\n      final Field fld = Unsafe.class.getDeclaredField(\"theUnsafe\");\r\n      fld.setAccessible(true);\r\n      return (Unsafe) fld.get(UtilUnsafe.class);\r\n    } catch (Exception e) {\r\n      throw new RuntimeException(\"Could not obtain access to sun.misc.Unsafe\", e);\r\n    }\r\n  }\r\n}\r\n"},{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"getUnsafe","lines":[[35,22,31]]},{"name":"compareAndSwapLong","lines":[[26,22,40]]}]}],"score":123,"fileName":"stephenc/high-scale-lib/blob/master/high-scale-lib/src/test/java/CAT_Tester/UnsafeCounter.java","fileContent":"//package org.cliffc.high_scale_lib;\r\nimport sun.misc.Unsafe;\r\nimport java.lang.reflect.*;\r\n\r\npublic final class UnsafeCounter extends Counter {\r\n  public String name() { return \"Unsafe\"; }\r\n  private static final Unsafe _unsafe = UtilUnsafe.getUnsafe();\r\n  private static final long CNT_OFFSET;\r\n  static { {\t\t\t// <clinit>\r\n    Field f = null;\r\n    try { \r\n      f = UnsafeCounter.class.getDeclaredField(\"_cnt\"); \r\n    } catch( java.lang.NoSuchFieldException e ) {\r\n      throw new Error(e);\r\n    } \r\n    CNT_OFFSET = _unsafe.objectFieldOffset(f);\r\n    }\r\n  }\r\n\r\n  private long _cnt;\r\n  public long get(){ return _cnt; }\r\n  public void add( final long x ) { \r\n    long cnt=0;\r\n    do { \r\n      cnt = _cnt;\r\n    } while( !_unsafe.compareAndSwapLong(this,CNT_OFFSET,cnt,cnt+x) );\r\n  }\r\n\r\n\r\n  private static class UtilUnsafe {\r\n    private UtilUnsafe() { } // dummy private constructor\r\n    public static Unsafe getUnsafe() {\r\n      // Not on bootclasspath\r\n      if( UtilUnsafe.class.getClassLoader() == null )\r\n        return Unsafe.getUnsafe();\r\n      try {\r\n        final Field fld = Unsafe.class.getDeclaredField(\"theUnsafe\");\r\n        fld.setAccessible(true);\r\n        return (Unsafe) fld.get(UtilUnsafe.class);\r\n      } catch (Exception e) {\r\n        throw new RuntimeException(\"Could not obtain access to sun.misc.Unsafe\", e);\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n"},{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"objectFieldOffset","lines":[[1037,22,39]]},{"name":"getUnsafe","lines":[[1013,26,35]]}]}],"score":387,"fileName":"scala/legacy-svn-scala/blob/master/src/forkjoin/scala/concurrent/forkjoin/ForkJoinTask.java","fileContent":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/licenses/publicdomain\n */\n\npackage scala.concurrent.forkjoin;\nimport java.io.Serializable;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.*;\n\n/**\n * Abstract base class for tasks that run within a {@link\n * ForkJoinPool}.  A ForkJoinTask is a thread-like entity that is much\n * lighter weight than a normal thread.  Huge numbers of tasks and\n * subtasks may be hosted by a small number of actual threads in a\n * ForkJoinPool, at the price of some usage limitations.\n *\n * <p> A \"main\" ForkJoinTask begins execution when submitted to a\n * {@link ForkJoinPool}. Once started, it will usually in turn start\n * other subtasks.  As indicated by the name of this class, many\n * programs using ForkJoinTasks employ only methods <code>fork</code>\n * and <code>join</code>, or derivatives such as\n * <code>invokeAll</code>.  However, this class also provides a number\n * of other methods that can come into play in advanced usages, as\n * well as extension mechanics that allow support of new forms of\n * fork/join processing.\n *\n * <p>A ForkJoinTask is a lightweight form of {@link Future}.  The\n * efficiency of ForkJoinTasks stems from a set of restrictions (that\n * are only partially statically enforceable) reflecting their\n * intended use as computational tasks calculating pure functions or\n * operating on purely isolated objects.  The primary coordination\n * mechanisms are {@link #fork}, that arranges asynchronous execution,\n * and {@link #join}, that doesn't proceed until the task's result has\n * been computed.  Computations should avoid <code>synchronized</code>\n * methods or blocks, and should minimize other blocking\n * synchronization apart from joining other tasks or using\n * synchronizers such as Phasers that are advertised to cooperate with\n * fork/join scheduling. Tasks should also not perform blocking IO,\n * and should ideally access variables that are completely independent\n * of those accessed by other running tasks. Minor breaches of these\n * restrictions, for example using shared output streams, may be\n * tolerable in practice, but frequent use may result in poor\n * performance, and the potential to indefinitely stall if the number\n * of threads not waiting for IO or other external synchronization\n * becomes exhausted. This usage restriction is in part enforced by\n * not permitting checked exceptions such as <code>IOExceptions</code>\n * to be thrown. However, computations may still encounter unchecked\n * exceptions, that are rethrown to callers attempting join\n * them. These exceptions may additionally include\n * RejectedExecutionExceptions stemming from internal resource\n * exhaustion such as failure to allocate internal task queues.\n *\n * <p>The primary method for awaiting completion and extracting\n * results of a task is {@link #join}, but there are several variants:\n * The {@link Future#get} methods support interruptible and/or timed\n * waits for completion and report results using <code>Future</code>\n * conventions. Method {@link #helpJoin} enables callers to actively\n * execute other tasks while awaiting joins, which is sometimes more\n * efficient but only applies when all subtasks are known to be\n * strictly tree-structured. Method {@link #invoke} is semantically\n * equivalent to <code>fork(); join()</code> but always attempts to\n * begin execution in the current thread. The \"<em>quiet</em>\" forms\n * of these methods do not extract results or report exceptions. These\n * may be useful when a set of tasks are being executed, and you need\n * to delay processing of results or exceptions until all complete.\n * Method <code>invokeAll</code> (available in multiple versions)\n * performs the most common form of parallel invocation: forking a set\n * of tasks and joining them all.\n *\n * <p> The ForkJoinTask class is not usually directly subclassed.\n * Instead, you subclass one of the abstract classes that support a\n * particular style of fork/join processing.  Normally, a concrete\n * ForkJoinTask subclass declares fields comprising its parameters,\n * established in a constructor, and then defines a <code>compute</code>\n * method that somehow uses the control methods supplied by this base\n * class. While these methods have <code>public</code> access (to allow\n * instances of different task subclasses to call each others\n * methods), some of them may only be called from within other\n * ForkJoinTasks. Attempts to invoke them in other contexts result in\n * exceptions or errors possibly including ClassCastException.\n *\n * <p>Most base support methods are <code>final</code> because their\n * implementations are intrinsically tied to the underlying\n * lightweight task scheduling framework, and so cannot be overridden.\n * Developers creating new basic styles of fork/join processing should\n * minimally implement <code>protected</code> methods\n * <code>exec</code>, <code>setRawResult</code>, and\n * <code>getRawResult</code>, while also introducing an abstract\n * computational method that can be implemented in its subclasses,\n * possibly relying on other <code>protected</code> methods provided\n * by this class.\n *\n * <p>ForkJoinTasks should perform relatively small amounts of\n * computations, othewise splitting into smaller tasks. As a very\n * rough rule of thumb, a task should perform more than 100 and less\n * than 10000 basic computational steps. If tasks are too big, then\n * parellelism cannot improve throughput. If too small, then memory\n * and internal task maintenance overhead may overwhelm processing.\n *\n * <p>ForkJoinTasks are <code>Serializable</code>, which enables them\n * to be used in extensions such as remote execution frameworks. It is\n * in general sensible to serialize tasks only before or after, but\n * not during execution. Serialization is not relied on during\n * execution itself.\n */\npublic abstract class ForkJoinTask<V> implements Future<V>, Serializable {\n\n    /**\n     * Run control status bits packed into a single int to minimize\n     * footprint and to ensure atomicity (via CAS).  Status is\n     * initially zero, and takes on nonnegative values until\n     * completed, upon which status holds COMPLETED. CANCELLED, or\n     * EXCEPTIONAL, which use the top 3 bits.  Tasks undergoing\n     * blocking waits by other threads have SIGNAL_MASK bits set --\n     * bit 15 for external (nonFJ) waits, and the rest a count of\n     * waiting FJ threads.  (This representation relies on\n     * ForkJoinPool max thread limits). Completion of a stolen task\n     * with SIGNAL_MASK bits set awakens waiter via notifyAll. Even\n     * though suboptimal for some purposes, we use basic builtin\n     * wait/notify to take advantage of \"monitor inflation\" in JVMs\n     * that we would otherwise need to emulate to avoid adding further\n     * per-task bookkeeping overhead. Note that bits 16-28 are\n     * currently unused. Also value 0x80000000 is available as spare\n     * completion value.\n     */\n    volatile int status; // accessed directy by pool and workers\n\n    static final int COMPLETION_MASK      = 0xe0000000;\n    static final int NORMAL               = 0xe0000000; // == mask\n    static final int CANCELLED            = 0xc0000000;\n    static final int EXCEPTIONAL          = 0xa0000000;\n    static final int SIGNAL_MASK          = 0x0000ffff;\n    static final int INTERNAL_SIGNAL_MASK = 0x00007fff;\n    static final int EXTERNAL_SIGNAL      = 0x00008000; // top bit of low word\n\n    /**\n     * Table of exceptions thrown by tasks, to enable reporting by\n     * callers. Because exceptions are rare, we don't directly keep\n     * them with task objects, but instead us a weak ref table.  Note\n     * that cancellation exceptions don't appear in the table, but are\n     * instead recorded as status values.\n     * Todo: Use ConcurrentReferenceHashMap\n     */\n    static final Map<ForkJoinTask<?>, Throwable> exceptionMap =\n        Collections.synchronizedMap\n        (new WeakHashMap<ForkJoinTask<?>, Throwable>());\n\n    // within-package utilities\n\n    /**\n     * Get current worker thread, or null if not a worker thread\n     */\n    static ForkJoinWorkerThread getWorker() {\n        Thread t = Thread.currentThread();\n        return ((t instanceof ForkJoinWorkerThread)?\n                (ForkJoinWorkerThread)t : null);\n    }\n\n    final boolean casStatus(int cmp, int val) {\n        return _unsafe.compareAndSwapInt(this, statusOffset, cmp, val);\n    }\n\n    /**\n     * Workaround for not being able to rethrow unchecked exceptions.\n     */\n    static void rethrowException(Throwable ex) {\n        if (ex != null)\n            _unsafe.throwException(ex);\n    }\n\n    // Setting completion status\n\n    /**\n     * Mark completion and wake up threads waiting to join this task.\n     * @param completion one of NORMAL, CANCELLED, EXCEPTIONAL\n     */\n    final void setCompletion(int completion) {\n        ForkJoinPool pool = getPool();\n        if (pool != null) {\n            int s; // Clear signal bits while setting completion status\n            do;while ((s = status) >= 0 && !casStatus(s, completion));\n\n            if ((s & SIGNAL_MASK) != 0) {\n                if ((s &= INTERNAL_SIGNAL_MASK) != 0)\n                    pool.updateRunningCount(s);\n                synchronized(this) { notifyAll(); }\n            }\n        }\n        else\n            externallySetCompletion(completion);\n    }\n\n    /**\n     * Version of setCompletion for non-FJ threads.  Leaves signal\n     * bits for unblocked threads to adjust, and always notifies.\n     */\n    private void externallySetCompletion(int completion) {\n        int s;\n        do;while ((s = status) >= 0 &&\n                  !casStatus(s, (s & SIGNAL_MASK) | completion));\n        synchronized(this) { notifyAll(); }\n    }\n\n    /**\n     * Sets status to indicate normal completion\n     */\n    final void setNormalCompletion() {\n        // Try typical fast case -- single CAS, no signal, not already done.\n        // Manually expand casStatus to improve chances of inlining it\n        if (!_unsafe.compareAndSwapInt(this, statusOffset, 0, NORMAL))\n            setCompletion(NORMAL);\n    }\n\n    // internal waiting and notification\n\n    /**\n     * Performs the actual monitor wait for awaitDone\n     */\n    private void doAwaitDone() {\n        // Minimize lock bias and in/de-flation effects by maximizing\n        // chances of waiting inside sync\n        try {\n            while (status >= 0)\n                synchronized(this) { if (status >= 0) wait(); }\n        } catch (InterruptedException ie) {\n            onInterruptedWait();\n        }\n    }\n\n    /**\n     * Performs the actual monitor wait for awaitDone\n     */\n    private void doAwaitDone(long startTime, long nanos) {\n        synchronized(this) {\n            try {\n                while (status >= 0) {\n                    long nt = nanos - System.nanoTime() - startTime;\n                    if (nt <= 0)\n                        break;\n                    wait(nt / 1000000, (int)(nt % 1000000));\n                }\n            } catch (InterruptedException ie) {\n                onInterruptedWait();\n            }\n        }\n    }\n\n    // Awaiting completion\n\n    /**\n     * Sets status to indicate there is joiner, then waits for join,\n     * surrounded with pool notifications.\n     * @return status upon exit\n     */\n    private int awaitDone(ForkJoinWorkerThread w, boolean maintainParallelism) {\n        ForkJoinPool pool = w == null? null : w.pool;\n        int s;\n        while ((s = status) >= 0) {\n            if (casStatus(s, pool == null? s|EXTERNAL_SIGNAL : s+1)) {\n                if (pool == null || !pool.preJoin(this, maintainParallelism))\n                    doAwaitDone();\n                if (((s = status) & INTERNAL_SIGNAL_MASK) != 0)\n                    adjustPoolCountsOnUnblock(pool);\n                break;\n            }\n        }\n        return s;\n    }\n\n    /**\n     * Timed version of awaitDone\n     * @return status upon exit\n     */\n    private int awaitDone(ForkJoinWorkerThread w, long nanos) {\n        ForkJoinPool pool = w == null? null : w.pool;\n        int s;\n        while ((s = status) >= 0) {\n            if (casStatus(s, pool == null? s|EXTERNAL_SIGNAL : s+1)) {\n                long startTime = System.nanoTime();\n                if (pool == null || !pool.preJoin(this, false))\n                    doAwaitDone(startTime, nanos);\n                if ((s = status) >= 0) {\n                    adjustPoolCountsOnCancelledWait(pool);\n                    s = status;\n                }\n                if (s < 0 && (s & INTERNAL_SIGNAL_MASK) != 0)\n                    adjustPoolCountsOnUnblock(pool);\n                break;\n            }\n        }\n        return s;\n    }\n\n    /**\n     * Notify pool that thread is unblocked. Called by signalled\n     * threads when woken by non-FJ threads (which is atypical).\n     */\n    private void adjustPoolCountsOnUnblock(ForkJoinPool pool) {\n        int s;\n        do;while ((s = status) < 0 && !casStatus(s, s & COMPLETION_MASK));\n        if (pool != null && (s &= INTERNAL_SIGNAL_MASK) != 0)\n            pool.updateRunningCount(s);\n    }\n\n    /**\n     * Notify pool to adjust counts on cancelled or timed out wait\n     */\n    private void adjustPoolCountsOnCancelledWait(ForkJoinPool pool) {\n        if (pool != null) {\n            int s;\n            while ((s = status) >= 0 && (s & INTERNAL_SIGNAL_MASK) != 0) {\n                if (casStatus(s, s - 1)) {\n                    pool.updateRunningCount(1);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Handle interruptions during waits.\n     */\n    private void onInterruptedWait() {\n        ForkJoinWorkerThread w = getWorker();\n        if (w == null)\n            Thread.currentThread().interrupt(); // re-interrupt\n        else if (w.isTerminating())\n            cancelIgnoringExceptions();\n        // else if FJworker, ignore interrupt\n    }\n\n    // Recording and reporting exceptions\n\n    private void setDoneExceptionally(Throwable rex) {\n        exceptionMap.put(this, rex);\n        setCompletion(EXCEPTIONAL);\n    }\n\n    /**\n     * Throws the exception associated with status s;\n     * @throws the exception\n     */\n    private void reportException(int s) {\n        if ((s &= COMPLETION_MASK) < NORMAL) {\n            if (s == CANCELLED)\n                throw new CancellationException();\n            else\n                rethrowException(exceptionMap.get(this));\n        }\n    }\n\n    /**\n     * Returns result or throws exception using j.u.c.Future conventions\n     * Only call when isDone known to be true.\n     */\n    private V reportFutureResult()\n        throws ExecutionException, InterruptedException {\n        int s = status & COMPLETION_MASK;\n        if (s < NORMAL) {\n            Throwable ex;\n            if (s == CANCELLED)\n                throw new CancellationException();\n            if (s == EXCEPTIONAL && (ex = exceptionMap.get(this)) != null)\n                throw new ExecutionException(ex);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n        return getRawResult();\n    }\n\n    /**\n     * Returns result or throws exception using j.u.c.Future conventions\n     * with timeouts\n     */\n    private V reportTimedFutureResult()\n        throws InterruptedException, ExecutionException, TimeoutException {\n        Throwable ex;\n        int s = status & COMPLETION_MASK;\n        if (s == NORMAL)\n            return getRawResult();\n        if (s == CANCELLED)\n            throw new CancellationException();\n        if (s == EXCEPTIONAL && (ex = exceptionMap.get(this)) != null)\n            throw new ExecutionException(ex);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        throw new TimeoutException();\n    }\n\n    // internal execution methods\n\n    /**\n     * Calls exec, recording completion, and rethrowing exception if\n     * encountered. Caller should normally check status before calling\n     * @return true if completed normally\n     */\n    private boolean tryExec() {\n        try { // try block must contain only call to exec\n            if (!exec())\n                return false;\n        } catch (Throwable rex) {\n            setDoneExceptionally(rex);\n            rethrowException(rex);\n            return false; // not reached\n        }\n        setNormalCompletion();\n        return true;\n    }\n\n    /**\n     * Main execution method used by worker threads. Invokes\n     * base computation unless already complete\n     */\n    final void quietlyExec() {\n        if (status >= 0) {\n            try {\n                if (!exec())\n                    return;\n            } catch(Throwable rex) {\n                setDoneExceptionally(rex);\n                return;\n            }\n            setNormalCompletion();\n        }\n    }\n\n    /**\n     * Calls exec, recording but not rethrowing exception\n     * Caller should normally check status before calling\n     * @return true if completed normally\n     */\n    private boolean tryQuietlyInvoke() {\n        try {\n            if (!exec())\n                return false;\n        } catch (Throwable rex) {\n            setDoneExceptionally(rex);\n            return false;\n        }\n        setNormalCompletion();\n        return true;\n    }\n\n    /**\n     * Cancel, ignoring any exceptions it throws\n     */\n    final void cancelIgnoringExceptions() {\n        try {\n            cancel(false);\n        } catch(Throwable ignore) {\n        }\n    }\n\n    /**\n     * Main implementation of helpJoin\n     */\n    private int busyJoin(ForkJoinWorkerThread w) {\n        int s;\n        ForkJoinTask<?> t;\n        while ((s = status) >= 0 && (t = w.scanWhileJoining(this)) != null)\n            t.quietlyExec();\n        return (s >= 0)? awaitDone(w, false) : s; // block if no work\n    }\n\n    // public methods\n\n    /**\n     * Arranges to asynchronously execute this task.  While it is not\n     * necessarily enforced, it is a usage error to fork a task more\n     * than once unless it has completed and been reinitialized.  This\n     * method may be invoked only from within ForkJoinTask\n     * computations. Attempts to invoke in other contexts result in\n     * exceptions or errors possibly including ClassCastException.\n     */\n    public final void fork() {\n        ((ForkJoinWorkerThread)(Thread.currentThread())).pushTask(this);\n    }\n\n    /**\n     * Returns the result of the computation when it is ready.\n     * This method differs from <code>get</code> in that abnormal\n     * completion results in RuntimeExceptions or Errors, not\n     * ExecutionExceptions.\n     *\n     * @return the computed result\n     */\n    public final V join() {\n        ForkJoinWorkerThread w = getWorker();\n        if (w == null || status < 0 || !w.unpushTask(this) || !tryExec())\n            reportException(awaitDone(w, true));\n        return getRawResult();\n    }\n\n    /**\n     * Commences performing this task, awaits its completion if\n     * necessary, and return its result.\n     * @throws Throwable (a RuntimeException, Error, or unchecked\n     * exception) if the underlying computation did so.\n     * @return the computed result\n     */\n    public final V invoke() {\n        if (status >= 0 && tryExec())\n            return getRawResult();\n        else\n            return join();\n    }\n\n    /**\n     * Forks both tasks, returning when <code>isDone</code> holds for\n     * both of them or an exception is encountered. This method may be\n     * invoked only from within ForkJoinTask computations. Attempts to\n     * invoke in other contexts result in exceptions or errors\n     * possibly including ClassCastException.\n     * @param t1 one task\n     * @param t2 the other task\n     * @throws NullPointerException if t1 or t2 are null\n     * @throws RuntimeException or Error if either task did so.\n     */\n    public static void invokeAll(ForkJoinTask<?>t1, ForkJoinTask<?> t2) {\n        t2.fork();\n        t1.invoke();\n        t2.join();\n    }\n\n    /**\n     * Forks the given tasks, returning when <code>isDone</code> holds\n     * for all of them. If any task encounters an exception, others\n     * may be cancelled.  This method may be invoked only from within\n     * ForkJoinTask computations. Attempts to invoke in other contexts\n     * result in exceptions or errors possibly including ClassCastException.\n     * @param tasks the array of tasks\n     * @throws NullPointerException if tasks or any element are null.\n     * @throws RuntimeException or Error if any task did so.\n     */\n    public static void invokeAll(ForkJoinTask<?>... tasks) {\n        Throwable ex = null;\n        int last = tasks.length - 1;\n        for (int i = last; i >= 0; --i) {\n            ForkJoinTask<?> t = tasks[i];\n            if (t == null) {\n                if (ex == null)\n                    ex = new NullPointerException();\n            }\n            else if (i != 0)\n                t.fork();\n            else {\n                t.quietlyInvoke();\n                if (ex == null)\n                    ex = t.getException();\n            }\n        }\n        for (int i = 1; i <= last; ++i) {\n            ForkJoinTask<?> t = tasks[i];\n            if (t != null) {\n                if (ex != null)\n                    t.cancel(false);\n                else {\n                    t.quietlyJoin();\n                    if (ex == null)\n                        ex = t.getException();\n                }\n            }\n        }\n        if (ex != null)\n            rethrowException(ex);\n    }\n\n    /**\n     * Forks all tasks in the collection, returning when\n     * <code>isDone</code> holds for all of them. If any task\n     * encounters an exception, others may be cancelled.  This method\n     * may be invoked only from within ForkJoinTask\n     * computations. Attempts to invoke in other contexts resul!t in\n     * exceptions or errors possibly including ClassCastException.\n     * @param tasks the collection of tasks\n     * @throws NullPointerException if tasks or any element are null.\n     * @throws RuntimeException or Error if any task did so.\n     */\n    public static void invokeAll(Collection<? extends ForkJoinTask<?>> tasks) {\n        if (!(tasks instanceof List)) {\n            invokeAll(tasks.toArray(new ForkJoinTask[tasks.size()]));\n            return;\n        }\n        List<? extends ForkJoinTask<?>> ts =\n            (List<? extends ForkJoinTask<?>>)tasks;\n        Throwable ex = null;\n        int last = ts.size() - 1;\n        for (int i = last; i >= 0; --i) {\n            ForkJoinTask<?> t = ts.get(i);\n            if (t == null) {\n                if (ex == null)\n                    ex = new NullPointerException();\n            }\n            else if (i != 0)\n                t.fork();\n            else {\n                t.quietlyInvoke();\n                if (ex == null)\n                    ex = t.getException();\n            }\n        }\n        for (int i = 1; i <= last; ++i) {\n            ForkJoinTask<?> t = ts.get(i);\n            if (t != null) {\n                if (ex != null)\n                    t.cancel(false);\n                else {\n                    t.quietlyJoin();\n                    if (ex == null)\n                        ex = t.getException();\n                }\n            }\n        }\n        if (ex != null)\n            rethrowException(ex);\n    }\n\n    /**\n     * Returns true if the computation performed by this task has\n     * completed (or has been cancelled).\n     * @return true if this computation has completed\n     */\n    public final boolean isDone() {\n        return status < 0;\n    }\n\n    /**\n     * Returns true if this task was cancelled.\n     * @return true if this task was cancelled\n     */\n    public final boolean isCancelled() {\n        return (status & COMPLETION_MASK) == CANCELLED;\n    }\n\n    /**\n     * Asserts that the results of this task's computation will not be\n     * used. If a cancellation occurs before atempting to execute this\n     * task, then execution will be suppressed, <code>isCancelled</code>\n     * will report true, and <code>join</code> will result in a\n     * <code>CancellationException</code> being thrown. Otherwise, when\n     * cancellation races with completion, there are no guarantees\n     * about whether <code>isCancelled</code> will report true, whether\n     * <code>join</code> will return normally or via an exception, or\n     * whether these behaviors will remain consistent upon repeated\n     * invocation.\n     *\n     * <p>This method may be overridden in subclasses, but if so, must\n     * still ensure that these minimal properties hold. In particular,\n     * the cancel method itself must not throw exceptions.\n     *\n     * <p> This method is designed to be invoked by <em>other</em>\n     * tasks. To terminate the current task, you can just return or\n     * throw an unchecked exception from its computation method, or\n     * invoke <code>completeExceptionally</code>.\n     *\n     * @param mayInterruptIfRunning this value is ignored in the\n     * default implementation because tasks are not in general\n     * cancelled via interruption.\n     *\n     * @return true if this task is now cancelled\n     */\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        setCompletion(CANCELLED);\n        return (status & COMPLETION_MASK) == CANCELLED;\n    }\n\n    /**\n     * Returns true if this task threw an exception or was cancelled\n     * @return true if this task threw an exception or was cancelled\n     */\n    public final boolean isCompletedAbnormally() {\n        return (status & COMPLETION_MASK) < NORMAL;\n    }\n\n    /**\n     * Returns the exception thrown by the base computation, or a\n     * CancellationException if cancelled, or null if none or if the\n     * method has not yet completed.\n     * @return the exception, or null if none\n     */\n    public final Throwable getException() {\n        int s = status & COMPLETION_MASK;\n        if (s >= NORMAL)\n            return null;\n        if (s == CANCELLED)\n            return new CancellationException();\n        return exceptionMap.get(this);\n    }\n\n    /**\n     * Completes this task abnormally, and if not already aborted or\n     * cancelled, causes it to throw the given exception upon\n     * <code>join</code> and related operations. This method may be used\n     * to induce exceptions in asynchronous tasks, or to force\n     * completion of tasks that would not otherwise complete.  Its use\n     * in other situations is likely to be wrong.  This method is\n     * overridable, but overridden versions must invoke <code>super</code>\n     * implementation to maintain guarantees.\n     *\n     * @param ex the exception to throw. If this exception is\n     * not a RuntimeException or Error, the actual exception thrown\n     * will be a RuntimeException with cause ex.\n     */\n    public void completeExceptionally(Throwable ex) {\n        setDoneExceptionally((ex instanceof RuntimeException) ||\n                             (ex instanceof Error)? ex :\n                             new RuntimeException(ex));\n    }\n\n    /**\n     * Completes this task, and if not already aborted or cancelled,\n     * returning a <code>null</code> result upon <code>join</code> and related\n     * operations. This method may be used to provide results for\n     * asynchronous tasks, or to provide alternative handling for\n     * tasks that would not otherwise complete normally. Its use in\n     * other situations is likely to be wrong. This method is\n     * overridable, but overridden versions must invoke <code>super</code>\n     * implementation to maintain guarantees.\n     *\n     * @param value the result value for this task.\n     */\n    public void complete(V value) {\n        try {\n            setRawResult(value);\n        } catch(Throwable rex) {\n            setDoneExceptionally(rex);\n            return;\n        }\n        setNormalCompletion();\n    }\n\n    public final V get() throws InterruptedException, ExecutionException {\n        ForkJoinWorkerThread w = getWorker();\n        if (w == null || status < 0 || !w.unpushTask(this) || !tryQuietlyInvoke())\n            awaitDone(w, true);\n        return reportFutureResult();\n    }\n\n    public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        ForkJoinWorkerThread w = getWorker();\n        if (w == null || status < 0 || !w.unpushTask(this) || !tryQuietlyInvoke())\n            awaitDone(w, unit.toNanos(timeout));\n        return reportTimedFutureResult();\n    }\n\n    /**\n     * Possibly executes other tasks until this task is ready, then\n     * returns the result of the computation.  This method may be more\n     * efficient than <code>join</code>, but is only applicable when\n     * there are no potemtial dependencies between continuation of the\n     * current task and that of any other task that might be executed\n     * while helping. (This usually holds for pure divide-and-conquer\n     * tasks). This method may be invoked only from within\n     * ForkJoinTask computations. Attempts to invoke in other contexts\n     * resul!t in exceptions or errors possibly including ClassCastException.\n     * @return the computed result\n     */\n    public final V helpJoin() {\n        ForkJoinWorkerThread w = (ForkJoinWorkerThread)(Thread.currentThread());\n        if (status < 0 || !w.unpushTask(this) || !tryExec())\n            reportException(busyJoin(w));\n        return getRawResult();\n    }\n\n    /**\n     * Possibly executes other tasks until this task is ready.  This\n     * method may be invoked only from within ForkJoinTask\n     * computations. Attempts to invoke in other contexts resul!t in\n     * exceptions or errors possibly including ClassCastException.\n     */\n    public final void quietlyHelpJoin() {\n        if (status >= 0) {\n            ForkJoinWorkerThread w =\n                (ForkJoinWorkerThread)(Thread.currentThread());\n            if (!w.unpushTask(this) || !tryQuietlyInvoke())\n                busyJoin(w);\n        }\n    }\n\n    /**\n     * Joins this task, without returning its result or throwing an\n     * exception. This method may be useful when processing\n     * collections of tasks when some have been cancelled or otherwise\n     * known to have aborted.\n     */\n    public final void quietlyJoin() {\n        if (status >= 0) {\n            ForkJoinWorkerThread w = getWorker();\n            if (w == null || !w.unpushTask(this) || !tryQuietlyInvoke())\n                awaitDone(w, true);\n        }\n    }\n\n    /**\n     * Commences performing this task and awaits its completion if\n     * necessary, without returning its result or throwing an\n     * exception. This method may be useful when processing\n     * collections of tasks when some have been cancelled or otherwise\n     * known to have aborted.\n     */\n    public final void quietlyInvoke() {\n        if (status >= 0 && !tryQuietlyInvoke())\n            quietlyJoin();\n    }\n\n    /**\n     * Possibly executes tasks until the pool hosting the current task\n     * {@link ForkJoinPool#isQuiescent}. This method may be of use in\n     * designs in which many tasks are forked, but none are explicitly\n     * joined, instead executing them until all are processed.\n     */\n    public static void helpQuiesce() {\n        ((ForkJoinWorkerThread)(Thread.currentThread())).\n            helpQuiescePool();\n    }\n\n    /**\n     * Resets the internal bookkeeping state of this task, allowing a\n     * subsequent <code>fork</code>. This method allows repeated reuse of\n     * this task, but only if reuse occurs when this task has either\n     * never been forked, or has been forked, then completed and all\n     * outstanding joins of this task have also completed. Effects\n     * under any other usage conditions are not guaranteed, and are\n     * almost surely wrong. This method may be useful when executing\n     * pre-constructed trees of subtasks in loops.\n     */\n    public void reinitialize() {\n        if ((status & COMPLETION_MASK) == EXCEPTIONAL)\n            exceptionMap.remove(this);\n        status = 0;\n    }\n\n    /**\n     * Returns the pool hosting the current task execution, or null\n     * if this task is executing outside of any pool.\n     * @return the pool, or null if none.\n     */\n    public static ForkJoinPool getPool() {\n        Thread t = Thread.currentThread();\n        return ((t instanceof ForkJoinWorkerThread)?\n                ((ForkJoinWorkerThread)t).pool : null);\n    }\n\n    /**\n     * Tries to unschedule this task for execution. This method will\n     * typically succeed if this task is the most recently forked task\n     * by the current thread, and has not commenced executing in\n     * another thread.  This method may be useful when arranging\n     * alternative local processing of tasks that could have been, but\n     * were not, stolen. This method may be invoked only from within\n     * ForkJoinTask computations. Attempts to invoke in other contexts\n     * result in exceptions or errors possibly including ClassCastException.\n     * @return true if unforked\n     */\n    public boolean tryUnfork() {\n        return ((ForkJoinWorkerThread)(Thread.currentThread())).unpushTask(this);\n    }\n\n    /**\n     * Returns an estimate of the number of tasks that have been\n     * forked by the current worker thread but not yet executed. This\n     * value may be useful for heuristic decisions about whether to\n     * fork other tasks.\n     * @return the number of tasks\n     */\n    public static int getQueuedTaskCount() {\n        return ((ForkJoinWorkerThread)(Thread.currentThread())).\n            getQueueSize();\n    }\n\n    /**\n     * Returns a estimate of how many more locally queued tasks are\n     * held by the current worker thread than there are other worker\n     * threads that might steal them.  This value may be useful for\n     * heuristic decisions about whether to fork other tasks. In many\n     * usages of ForkJoinTasks, at steady state, each worker should\n     * aim to maintain a small constant surplus (for example, 3) of\n     * tasks, and to process computations locally if this threshold is\n     * exceeded.\n     * @return the surplus number of tasks, which may be negative\n     */\n    public static int getSurplusQueuedTaskCount() {\n        return ((ForkJoinWorkerThread)(Thread.currentThread()))\n            .getEstimatedSurplusTaskCount();\n    }\n\n    // Extension methods\n\n    /**\n     * Returns the result that would be returned by <code>join</code>,\n     * even if this task completed abnormally, or null if this task is\n     * not known to have been completed.  This method is designed to\n     * aid debugging, as well as to support extensions. Its use in any\n     * other context is discouraged.\n     *\n     * @return the result, or null if not completed.\n     */\n    public abstract V getRawResult();\n\n    /**\n     * Forces the given value to be returned as a result.  This method\n     * is designed to support extensions, and should not in general be\n     * called otherwise.\n     *\n     * @param value the value\n     */\n    protected abstract void setRawResult(V value);\n\n    /**\n     * Immediately performs the base action of this task.  This method\n     * is designed to support extensions, and should not in general be\n     * called otherwise. The return value controls whether this task\n     * is considered to be done normally. It may return false in\n     * asynchronous actions that require explicit invocations of\n     * <code>complete</code> to become joinable. It may throw exceptions\n     * to indicate abnormal exit.\n     * @return true if completed normally\n     * @throws Error or RuntimeException if encountered during computation\n     */\n    protected abstract boolean exec();\n\n    /**\n     * Returns, but does not unschedule or execute, the task queued by\n     * the current thread but not yet executed, if one is\n     * available. There is no guarantee that this task will actually\n     * be polled or executed next.  This method is designed primarily\n     * to support extensions, and is unlikely to be useful otherwise.\n     * This method may be invoked only from within ForkJoinTask\n     * computations. Attempts to invoke in other contexts result in\n     * exceptions or errors possibly including ClassCastException.\n     *\n     * @return the next task, or null if none are available\n     */\n    protected static ForkJoinTask<?> peekNextLocalTask() {\n        return ((ForkJoinWorkerThread)(Thread.currentThread())).peekTask();\n    }\n\n    /**\n     * Unschedules and returns, without executing, the next task\n     * queued by the current thread but not yet executed.  This method\n     * is designed primarily to support extensions, and is unlikely to\n     * be useful otherwise.  This method may be invoked only from\n     * within ForkJoinTask computations. Attempts to invoke in other\n     * contexts result in exceptions or errors possibly including\n     * ClassCastException.\n     *\n     * @return the next task, or null if none are available\n     */\n    protected static ForkJoinTask<?> pollNextLocalTask() {\n        return ((ForkJoinWorkerThread)(Thread.currentThread())).pollLocalTask();\n    }\n    \n    /**\n     * Unschedules and returns, without executing, the next task\n     * queued by the current thread but not yet executed, if one is\n     * available, or if not available, a task that was forked by some\n     * other thread, if available. Availability may be transient, so a\n     * <code>null</code> result does not necessarily imply quiecence\n     * of the pool this task is operating in.  This method is designed\n     * primarily to support extensions, and is unlikely to be useful\n     * otherwise.  This method may be invoked only from within\n     * ForkJoinTask computations. Attempts to invoke in other contexts\n     * result in exceptions or errors possibly including\n     * ClassCastException.\n     *\n     * @return a task, or null if none are available\n     */\n    protected static ForkJoinTask<?> pollTask() {\n        return ((ForkJoinWorkerThread)(Thread.currentThread())).\n            pollTask();\n    }\n\n    // Serialization support\n\n    private static final long serialVersionUID = -7721805057305804111L;\n\n    /**\n     * Save the state to a stream.\n     *\n     * @serialData the current run status and the exception thrown\n     * during execution, or null if none.\n     * @param s the stream\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n        s.defaultWriteObject();\n        s.writeObject(getException());\n    }\n\n    /**\n     * Reconstitute the instance from a stream.\n     * @param s the stream\n     */\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        s.defaultReadObject();\n        status &= ~INTERNAL_SIGNAL_MASK; // clear internal signal counts\n        status |= EXTERNAL_SIGNAL; // conservatively set external signal\n        Object ex = s.readObject();\n        if (ex != null)\n            setDoneExceptionally((Throwable)ex);\n    }\n\n    // Temporary Unsafe mechanics for preliminary release\n    private static Unsafe getUnsafe() throws Throwable {\n        try {\n            return Unsafe.getUnsafe();\n        } catch (SecurityException se) {\n            try {\n                return java.security.AccessController.doPrivileged\n                    (new java.security.PrivilegedExceptionAction<Unsafe>() {\n                        public Unsafe run() throws Exception {\n                            return getUnsafePrivileged();\n                        }});\n            } catch (java.security.PrivilegedActionException e) {\n                throw e.getCause();\n            }\n        }\n    }\n\n    private static Unsafe getUnsafePrivileged()\n            throws NoSuchFieldException, IllegalAccessException {\n        Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (Unsafe) f.get(null);\n    }\n\n    private static long fieldOffset(String fieldName, Unsafe unsafe)\n            throws NoSuchFieldException {\n        // do not use _unsafe to avoid NPE\n        return unsafe.objectFieldOffset\n            (ForkJoinTask.class.getDeclaredField(fieldName));\n    }\n\n    static final Unsafe _unsafe;\n    static final long statusOffset;\n\n    static {\n        Unsafe tmpUnsafe = null;\n        long tmpStatusOffset = 0;\n        try {\n            tmpUnsafe = getUnsafe();\n            tmpStatusOffset = fieldOffset(\"status\", tmpUnsafe);\n        } catch (Throwable e) {\n            // Ignore the failure to load sun.misc.Unsafe on Android so\n            // that platform can use the actor library without the\n            // fork/join scheduler.\n            String vmVendor = System.getProperty(\"java.vm.vendor\");\n            if (!vmVendor.contains(\"Android\")) {\n\t        throw new RuntimeException(\"Could not initialize intrinsics\", e);\n            }\n        }\n        _unsafe = tmpUnsafe;\n\tstatusOffset = tmpStatusOffset;\n    }\n\n}\n"},{"types":[{"name":"sun.misc.Unsafe","props":[{"name":"getUnsafe","lines":[[798,26,35]]}]}],"score":387,"fileName":"scala/legacy-svn-scala/blob/master/src/forkjoin/scala/concurrent/forkjoin/LinkedTransferQueue.java","fileContent":"/*\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/licenses/publicdomain\n */\n\npackage scala.concurrent.forkjoin;\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\nimport java.util.concurrent.atomic.*;\nimport java.util.*;\nimport java.io.*;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.*;\n\n/**\n * An unbounded {@linkplain TransferQueue} based on linked nodes.\n * This queue orders elements FIFO (first-in-first-out) with respect\n * to any given producer.  The <em>head</em> of the queue is that\n * element that has been on the queue the longest time for some\n * producer.  The <em>tail</em> of the queue is that element that has\n * been on the queue the shortest time for some producer.\n *\n * <p>Beware that, unlike in most collections, the {@code size}\n * method is <em>NOT</em> a constant-time operation. Because of the\n * asynchronous nature of these queues, determining the current number\n * of elements requires a traversal of the elements.\n *\n * <p>This class and its iterator implement all of the\n * <em>optional</em> methods of the {@link Collection} and {@link\n * Iterator} interfaces.\n *\n * <p>Memory consistency effects: As with other concurrent\n * collections, actions in a thread prior to placing an object into a\n * {@code LinkedTransferQueue}\n * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n * actions subsequent to the access or removal of that element from\n * the {@code LinkedTransferQueue} in another thread.\n *\n * <p>This class is a member of the\n * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n * Java Collections Framework</a>.\n *\n * @since 1.7\n * @author Doug Lea\n * @param <E> the type of elements held in this collection\n *\n */\npublic class LinkedTransferQueue<E> extends AbstractQueue<E>\n    implements TransferQueue<E>, java.io.Serializable {\n    private static final long serialVersionUID = -3223113410248163686L;\n\n    /*\n     * This class extends the approach used in FIFO-mode\n     * SynchronousQueues. See the internal documentation, as well as\n     * the PPoPP 2006 paper \"Scalable Synchronous Queues\" by Scherer,\n     * Lea & Scott\n     * (http://www.cs.rice.edu/~wns1/papers/2006-PPoPP-SQ.pdf)\n     *\n     * The main extension is to provide different Wait modes for the\n     * main \"xfer\" method that puts or takes items.  These don't\n     * impact the basic dual-queue logic, but instead control whether\n     * or how threads block upon insertion of request or data nodes\n     * into the dual queue. It also uses slightly different\n     * conventions for tracking whether nodes are off-list or\n     * cancelled.\n     */\n\n    // Wait modes for xfer method\n    static final int NOWAIT  = 0;\n    static final int TIMEOUT = 1;\n    static final int WAIT    = 2;\n\n    /** The number of CPUs, for spin control */\n    static final int NCPUS = Runtime.getRuntime().availableProcessors();\n\n    /**\n     * The number of times to spin before blocking in timed waits.\n     * The value is empirically derived -- it works well across a\n     * variety of processors and OSes. Empirically, the best value\n     * seems not to vary with number of CPUs (beyond 2) so is just\n     * a constant.\n     */\n    static final int maxTimedSpins = (NCPUS < 2)? 0 : 32;\n\n    /**\n     * The number of times to spin before blocking in untimed waits.\n     * This is greater than timed value because untimed waits spin\n     * faster since they don't need to check times on each spin.\n     */\n    static final int maxUntimedSpins = maxTimedSpins * 16;\n\n    /**\n     * The number of nanoseconds for which it is faster to spin\n     * rather than to use timed park. A rough estimate suffices.\n     */\n    static final long spinForTimeoutThreshold = 1000L;\n\n    /**\n     * Node class for LinkedTransferQueue. Opportunistically\n     * subclasses from AtomicReference to represent item. Uses Object,\n     * not E, to allow setting item to \"this\" after use, to avoid\n     * garbage retention. Similarly, setting the next field to this is\n     * used as sentinel that node is off list.\n     */\n    static final class QNode extends AtomicReference<Object> {\n        volatile QNode next;\n        volatile Thread waiter;       // to control park/unpark\n        final boolean isData;\n        QNode(Object item, boolean isData) {\n            super(item);\n            this.isData = isData;\n        }\n\n        static final AtomicReferenceFieldUpdater<QNode, QNode>\n            nextUpdater = AtomicReferenceFieldUpdater.newUpdater\n            (QNode.class, QNode.class, \"next\");\n\n        final boolean casNext(QNode cmp, QNode val) {\n            return nextUpdater.compareAndSet(this, cmp, val);\n        }\n\n        final void clearNext() {\n            nextUpdater.lazySet(this, this);\n        }\n\n    }\n\n    /**\n     * Padded version of AtomicReference used for head, tail and\n     * cleanMe, to alleviate contention across threads CASing one vs\n     * the other.\n     */\n    static final class PaddedAtomicReference<T> extends AtomicReference<T> {\n        // enough padding for 64bytes with 4byte refs\n        Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;\n        PaddedAtomicReference(T r) { super(r); }\n    }\n\n\n    /** head of the queue */\n    private transient final PaddedAtomicReference<QNode> head;\n    /** tail of the queue */\n    private transient final PaddedAtomicReference<QNode> tail;\n\n    /**\n     * Reference to a cancelled node that might not yet have been\n     * unlinked from queue because it was the last inserted node\n     * when it cancelled.\n     */\n    private transient final PaddedAtomicReference<QNode> cleanMe;\n\n    /**\n     * Tries to cas nh as new head; if successful, unlink\n     * old head's next node to avoid garbage retention.\n     */\n    private boolean advanceHead(QNode h, QNode nh) {\n        if (h == head.get() && head.compareAndSet(h, nh)) {\n            h.clearNext(); // forget old next\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Puts or takes an item. Used for most queue operations (except\n     * poll() and tryTransfer()). See the similar code in\n     * SynchronousQueue for detailed explanation.\n     *\n     * @param e the item or if null, signifies that this is a take\n     * @param mode the wait mode: NOWAIT, TIMEOUT, WAIT\n     * @param nanos timeout in nanosecs, used only if mode is TIMEOUT\n     * @return an item, or null on failure\n     */\n    private Object xfer(Object e, int mode, long nanos) {\n        boolean isData = (e != null);\n        QNode s = null;\n        final PaddedAtomicReference<QNode> head = this.head;\n        final PaddedAtomicReference<QNode> tail = this.tail;\n\n        for (;;) {\n            QNode t = tail.get();\n            QNode h = head.get();\n\n            if (t != null && (t == h || t.isData == isData)) {\n                if (s == null)\n                    s = new QNode(e, isData);\n                QNode last = t.next;\n                if (last != null) {\n                    if (t == tail.get())\n                        tail.compareAndSet(t, last);\n                }\n                else if (t.casNext(null, s)) {\n                    tail.compareAndSet(t, s);\n                    return awaitFulfill(t, s, e, mode, nanos);\n                }\n            }\n\n            else if (h != null) {\n                QNode first = h.next;\n                if (t == tail.get() && first != null &&\n                    advanceHead(h, first)) {\n                    Object x = first.get();\n                    if (x != first && first.compareAndSet(x, e)) {\n                        LockSupport.unpark(first.waiter);\n                        return isData? e : x;\n                    }\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Version of xfer for poll() and tryTransfer, which\n     * simplifies control paths both here and in xfer.\n     */\n    private Object fulfill(Object e) {\n        boolean isData = (e != null);\n        final PaddedAtomicReference<QNode> head = this.head;\n        final PaddedAtomicReference<QNode> tail = this.tail;\n\n        for (;;) {\n            QNode t = tail.get();\n            QNode h = head.get();\n\n            if (t != null && (t == h || t.isData == isData)) {\n                QNode last = t.next;\n                if (t == tail.get()) {\n                    if (last != null)\n                        tail.compareAndSet(t, last);\n                    else\n                        return null;\n                }\n            }\n            else if (h != null) {\n                QNode first = h.next;\n                if (t == tail.get() &&\n                    first != null &&\n                    advanceHead(h, first)) {\n                    Object x = first.get();\n                    if (x != first && first.compareAndSet(x, e)) {\n                        LockSupport.unpark(first.waiter);\n                        return isData? e : x;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Spins/blocks until node s is fulfilled or caller gives up,\n     * depending on wait mode.\n     *\n     * @param pred the predecessor of waiting node\n     * @param s the waiting node\n     * @param e the comparison value for checking match\n     * @param mode mode\n     * @param nanos timeout value\n     * @return matched item, or s if cancelled\n     */\n    private Object awaitFulfill(QNode pred, QNode s, Object e,\n                                int mode, long nanos) {\n        if (mode == NOWAIT)\n            return null;\n\n        long lastTime = (mode == TIMEOUT)? System.nanoTime() : 0;\n        Thread w = Thread.currentThread();\n        int spins = -1; // set to desired spin count below\n        for (;;) {\n            if (w.isInterrupted())\n                s.compareAndSet(e, s);\n            Object x = s.get();\n            if (x != e) {                 // Node was matched or cancelled\n                advanceHead(pred, s);     // unlink if head\n                if (x == s) {             // was cancelled\n                    clean(pred, s);\n                    return null;\n                }\n                else if (x != null) {\n                    s.set(s);             // avoid garbage retention\n                    return x;\n                }\n                else\n                    return e;\n            }\n            if (mode == TIMEOUT) {\n                long now = System.nanoTime();\n                nanos -= now - lastTime;\n                lastTime = now;\n                if (nanos <= 0) {\n                    s.compareAndSet(e, s); // try to cancel\n                    continue;\n                }\n            }\n            if (spins < 0) {\n                QNode h = head.get(); // only spin if at head\n                spins = ((h != null && h.next == s) ?\n                         (mode == TIMEOUT?\n                          maxTimedSpins : maxUntimedSpins) : 0);\n            }\n            if (spins > 0)\n                --spins;\n            else if (s.waiter == null)\n                s.waiter = w;\n            else if (mode != TIMEOUT) {\n                LockSupport.park(this);\n                s.waiter = null;\n                spins = -1;\n            }\n            else if (nanos > spinForTimeoutThreshold) {\n                LockSupport.parkNanos(this, nanos);\n                s.waiter = null;\n                spins = -1;\n            }\n        }\n    }\n\n    /**\n     * Returns validated tail for use in cleaning methods.\n     */\n    private QNode getValidatedTail() {\n        for (;;) {\n            QNode h = head.get();\n            QNode first = h.next;\n            if (first != null && first.next == first) { // help advance\n                advanceHead(h, first);\n                continue;\n            }\n            QNode t = tail.get();\n            QNode last = t.next;\n            if (t == tail.get()) {\n                if (last != null)\n                    tail.compareAndSet(t, last); // help advance\n                else\n                    return t;\n            }\n        }\n    }\n\n    /**\n     * Gets rid of cancelled node s with original predecessor pred.\n     *\n     * @param pred predecessor of cancelled node\n     * @param s the cancelled node\n     */\n    private void clean(QNode pred, QNode s) {\n        Thread w = s.waiter;\n        if (w != null) {             // Wake up thread\n            s.waiter = null;\n            if (w != Thread.currentThread())\n                LockSupport.unpark(w);\n        }\n\n        if (pred == null)\n            return;\n\n        /*\n         * At any given time, exactly one node on list cannot be\n         * deleted -- the last inserted node. To accommodate this, if\n         * we cannot delete s, we save its predecessor as \"cleanMe\",\n         * processing the previously saved version first. At least one\n         * of node s or the node previously saved can always be\n         * processed, so this always terminates.\n         */\n        while (pred.next == s) {\n            QNode oldpred = reclean();  // First, help get rid of cleanMe\n            QNode t = getValidatedTail();\n            if (s != t) {               // If not tail, try to unsplice\n                QNode sn = s.next;      // s.next == s means s already off list\n                if (sn == s || pred.casNext(s, sn))\n                    break;\n            }\n            else if (oldpred == pred || // Already saved\n                     (oldpred == null && cleanMe.compareAndSet(null, pred)))\n                break;                  // Postpone cleaning\n        }\n    }\n\n    /**\n     * Tries to unsplice the cancelled node held in cleanMe that was\n     * previously uncleanable because it was at tail.\n     *\n     * @return current cleanMe node (or null)\n     */\n    private QNode reclean() {\n        /*\n         * cleanMe is, or at one time was, predecessor of cancelled\n         * node s that was the tail so could not be unspliced.  If s\n         * is no longer the tail, try to unsplice if necessary and\n         * make cleanMe slot available.  This differs from similar\n         * code in clean() because we must check that pred still\n         * points to a cancelled node that must be unspliced -- if\n         * not, we can (must) clear cleanMe without unsplicing.\n         * This can loop only due to contention on casNext or\n         * clearing cleanMe.\n         */\n        QNode pred;\n        while ((pred = cleanMe.get()) != null) {\n            QNode t = getValidatedTail();\n            QNode s = pred.next;\n            if (s != t) {\n                QNode sn;\n                if (s == null || s == pred || s.get() != s ||\n                    (sn = s.next) == s || pred.casNext(s, sn))\n                    cleanMe.compareAndSet(pred, null);\n            }\n            else // s is still tail; cannot clean\n                break;\n        }\n        return pred;\n    }\n\n    /**\n     * Creates an initially empty {@code LinkedTransferQueue}.\n     */\n    public LinkedTransferQueue() {\n        QNode dummy = new QNode(null, false);\n        head = new PaddedAtomicReference<QNode>(dummy);\n        tail = new PaddedAtomicReference<QNode>(dummy);\n        cleanMe = new PaddedAtomicReference<QNode>(null);\n    }\n\n    /**\n     * Creates a {@code LinkedTransferQueue}\n     * initially containing the elements of the given collection,\n     * added in traversal order of the collection's iterator.\n     *\n     * @param c the collection of elements to initially contain\n     * @throws NullPointerException if the specified collection or any\n     *         of its elements are null\n     */\n    public LinkedTransferQueue(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n\n    public void put(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        if (Thread.interrupted()) throw new InterruptedException();\n        xfer(e, NOWAIT, 0);\n    }\n\n    public boolean offer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        if (Thread.interrupted()) throw new InterruptedException();\n        xfer(e, NOWAIT, 0);\n        return true;\n    }\n\n    public boolean offer(E e) {\n        if (e == null) throw new NullPointerException();\n        xfer(e, NOWAIT, 0);\n        return true;\n    }\n\n    public boolean add(E e) {\n        if (e == null) throw new NullPointerException();\n        xfer(e, NOWAIT, 0);\n        return true;\n    }\n\n    public void transfer(E e) throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        if (xfer(e, WAIT, 0) == null) {\n            Thread.interrupted();\n            throw new InterruptedException();\n        }\n    }\n\n    public boolean tryTransfer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n        if (e == null) throw new NullPointerException();\n        if (xfer(e, TIMEOUT, unit.toNanos(timeout)) != null)\n            return true;\n        if (!Thread.interrupted())\n            return false;\n        throw new InterruptedException();\n    }\n\n    public boolean tryTransfer(E e) {\n        if (e == null) throw new NullPointerException();\n        return fulfill(e) != null;\n    }\n\n    public E take() throws InterruptedException {\n        Object e = xfer(null, WAIT, 0);\n        if (e != null)\n            return (E)e;\n        Thread.interrupted();\n        throw new InterruptedException();\n    }\n\n    public E poll(long timeout, TimeUnit unit) throws InterruptedException {\n        Object e = xfer(null, TIMEOUT, unit.toNanos(timeout));\n        if (e != null || !Thread.interrupted())\n            return (E)e;\n        throw new InterruptedException();\n    }\n\n    public E poll() {\n        return (E)fulfill(null);\n    }\n\n    public int drainTo(Collection<? super E> c) {\n        if (c == null)\n            throw new NullPointerException();\n        if (c == this)\n            throw new IllegalArgumentException();\n        int n = 0;\n        E e;\n        while ( (e = poll()) != null) {\n            c.add(e);\n            ++n;\n        }\n        return n;\n    }\n\n    public int drainTo(Collection<? super E> c, int maxElements) {\n        if (c == null)\n            throw new NullPointerException();\n        if (c == this)\n            throw new IllegalArgumentException();\n        int n = 0;\n        E e;\n        while (n < maxElements && (e = poll()) != null) {\n            c.add(e);\n            ++n;\n        }\n        return n;\n    }\n\n    // Traversal-based methods\n\n    /**\n     * Returns head after performing any outstanding helping steps.\n     */\n    private QNode traversalHead() {\n        for (;;) {\n            QNode t = tail.get();\n            QNode h = head.get();\n            if (h != null && t != null) {\n                QNode last = t.next;\n                QNode first = h.next;\n                if (t == tail.get()) {\n                    if (last != null)\n                        tail.compareAndSet(t, last);\n                    else if (first != null) {\n                        Object x = first.get();\n                        if (x == first)\n                            advanceHead(h, first);\n                        else\n                            return h;\n                    }\n                    else\n                        return h;\n                }\n            }\n            reclean();\n        }\n    }\n\n\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n    /**\n     * Iterators. Basic strategy is to traverse list, treating\n     * non-data (i.e., request) nodes as terminating list.\n     * Once a valid data node is found, the item is cached\n     * so that the next call to next() will return it even\n     * if subsequently removed.\n     */\n    class Itr implements Iterator<E> {\n        QNode next;        // node to return next\n        QNode pnext;       // predecessor of next\n        QNode snext;       // successor of next\n        QNode curr;        // last returned node, for remove()\n        QNode pcurr;       // predecessor of curr, for remove()\n        E nextItem;        // Cache of next item, once commited to in next\n\n        Itr() {\n            findNext();\n        }\n\n        /**\n         * Ensures next points to next valid node, or null if none.\n         */\n        void findNext() {\n            for (;;) {\n                QNode pred = pnext;\n                QNode q = next;\n                if (pred == null || pred == q) {\n                    pred = traversalHead();\n                    q = pred.next;\n                }\n                if (q == null || !q.isData) {\n                    next = null;\n                    return;\n                }\n                Object x = q.get();\n                QNode s = q.next;\n                if (x != null && q != x && q != s) {\n                    nextItem = (E)x;\n                    snext = s;\n                    pnext = pred;\n                    next = q;\n                    return;\n                }\n                pnext = q;\n                next = s;\n            }\n        }\n\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        public E next() {\n            if (next == null) throw new NoSuchElementException();\n            pcurr = pnext;\n            curr = next;\n            pnext = next;\n            next = snext;\n            E x = nextItem;\n            findNext();\n            return x;\n        }\n\n        public void remove() {\n            QNode p = curr;\n            if (p == null)\n                throw new IllegalStateException();\n            Object x = p.get();\n            if (x != null && x != p && p.compareAndSet(x, p))\n                clean(pcurr, p);\n        }\n    }\n\n    public E peek() {\n        for (;;) {\n            QNode h = traversalHead();\n            QNode p = h.next;\n            if (p == null)\n                return null;\n            Object x = p.get();\n            if (p != x) {\n                if (!p.isData)\n                    return null;\n                if (x != null)\n                    return (E)x;\n            }\n        }\n    }\n\n    public boolean isEmpty() {\n        for (;;) {\n            QNode h = traversalHead();\n            QNode p = h.next;\n            if (p == null)\n                return true;\n            Object x = p.get();\n            if (p != x) {\n                if (!p.isData)\n                    return true;\n                if (x != null)\n                    return false;\n            }\n        }\n    }\n\n    public boolean hasWaitingConsumer() {\n        for (;;) {\n            QNode h = traversalHead();\n            QNode p = h.next;\n            if (p == null)\n                return false;\n            Object x = p.get();\n            if (p != x)\n                return !p.isData;\n        }\n    }\n\n    /**\n     * Returns the number of elements in this queue.  If this queue\n     * contains more than {@code Integer.MAX_VALUE} elements, returns\n     * {@code Integer.MAX_VALUE}.\n     *\n     * <p>Beware that, unlike in most collections, this method is\n     * <em>NOT</em> a constant-time operation. Because of the\n     * asynchronous nature of these queues, determining the current\n     * number of elements requires an O(n) traversal.\n     *\n     * @return the number of elements in this queue\n     */\n    public int size() {\n        int count = 0;\n        QNode h = traversalHead();\n        for (QNode p = h.next; p != null && p.isData; p = p.next) {\n            Object x = p.get();\n            if (x != null && x != p) {\n                if (++count == Integer.MAX_VALUE) // saturated\n                    break;\n            }\n        }\n        return count;\n    }\n\n    public int getWaitingConsumerCount() {\n        int count = 0;\n        QNode h = traversalHead();\n        for (QNode p = h.next; p != null && !p.isData; p = p.next) {\n            if (p.get() == null) {\n                if (++count == Integer.MAX_VALUE)\n                    break;\n            }\n        }\n        return count;\n    }\n\n    public int remainingCapacity() {\n        return Integer.MAX_VALUE;\n    }\n\n    public boolean remove(Object o) {\n        if (o == null)\n            return false;\n        for (;;) {\n            QNode pred = traversalHead();\n            for (;;) {\n                QNode q = pred.next;\n                if (q == null || !q.isData)\n                    return false;\n                if (q == pred) // restart\n                    break;\n                Object x = q.get();\n                if (x != null && x != q && o.equals(x) &&\n                    q.compareAndSet(x, q)) {\n                    clean(pred, q);\n                    return true;\n                }\n                pred = q;\n            }\n        }\n    }\n\n    /**\n     * Save the state to a stream (that is, serialize it).\n     *\n     * @serialData All of the elements (each an {@code E}) in\n     * the proper order, followed by a null\n     * @param s the stream\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n        s.defaultWriteObject();\n        for (E e : this)\n            s.writeObject(e);\n        // Use trailing null as sentinel\n        s.writeObject(null);\n    }\n\n    /**\n     * Reconstitute the Queue instance from a stream (that is,\n     * deserialize it).\n     * @param s the stream\n     */\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        s.defaultReadObject();\n        resetHeadAndTail();\n        for (;;) {\n            E item = (E)s.readObject();\n            if (item == null)\n                break;\n            else\n                offer(item);\n        }\n    }\n\n\n    // Support for resetting head/tail while deserializing\n    private void resetHeadAndTail() {\n        QNode dummy = new QNode(null, false);\n        _unsafe.putObjectVolatile(this, headOffset,\n                                  new PaddedAtomicReference<QNode>(dummy));\n        _unsafe.putObjectVolatile(this, tailOffset,\n                                  new PaddedAtomicReference<QNode>(dummy));\n        _unsafe.putObjectVolatile(this, cleanMeOffset,\n                                  new PaddedAtomicReference<QNode>(null));\n    }\n\n    // Temporary Unsafe mechanics for preliminary release\n    private static Unsafe getUnsafe() throws Throwable {\n        try {\n            return Unsafe.getUnsafe();\n        } catch (SecurityException se) {\n            try {\n                return java.security.AccessController.doPrivileged\n                    (new java.security.PrivilegedExceptionAction<Unsafe>() {\n                        public Unsafe run() throws Exception {\n                            return getUnsafePrivileged();\n                        }});\n            } catch (java.security.PrivilegedActionException e) {\n                throw e.getCause();\n            }\n        }\n    }\n\n    private static Unsafe getUnsafePrivileged()\n            throws NoSuchFieldException, IllegalAccessException {\n        Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (Unsafe) f.get(null);\n    }\n\n    private static long fieldOffset(String fieldName)\n            throws NoSuchFieldException {\n        return _unsafe.objectFieldOffset\n            (LinkedTransferQueue.class.getDeclaredField(fieldName));\n    }\n\n    private static final Unsafe _unsafe;\n    private static final long headOffset;\n    private static final long tailOffset;\n    private static final long cleanMeOffset;\n    static {\n        try {\n            _unsafe = getUnsafe();\n            headOffset = fieldOffset(\"head\");\n            tailOffset = fieldOffset(\"tail\");\n            cleanMeOffset = fieldOffset(\"cleanMe\");\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Could not initialize intrinsics\", e);\n        }\n    }\n\n}\n"}],"total_hits":8}